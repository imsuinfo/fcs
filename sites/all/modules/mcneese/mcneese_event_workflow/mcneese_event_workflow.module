<?php

/**
 * @file
 * McNeese State University Event Workflow module.
 */

/**
 * @defgroup mcneese_event_workflow McNeese Event Workflow
 * @{
 * Provides Workflow specific module functionality for the Events Workflow
 * System.
 */

/**
 * Provides a status for 'soft-delete'.
 * Event is considered deleted, but actually still exists.
 */
define('MEW_EVENT_STATUS_DELETED', 0);

/**
 * This is the normal status of an event, event locks dates and times from others.
 */
define('MEW_EVENT_STATUS_LOCKED', 1);

/**
 * This is the normal status of an event, event does not lock dates and times from others.
 */
define('MEW_EVENT_STATUS_UNLOCKED', 2);

/**
 * This event has been accepted and no other event make take up its time slots.
 */
define('MEW_EVENT_STATUS_CLOSED_ACCEPTED', 3);

/**
 * This event has been denied, the time slots are available.
 */
define('MEW_EVENT_STATUS_CLOSED_DENIED', 4);

/**
 * This event was not available for the time slots were not available when the request was made.
 */
define('MEW_EVENT_STATUS_CLOSED_UNAVAILABLE', 5);

/**
 * This event was not available for the time slots were not available when the request was made.
 * Another, yet to be approved, event had the time slot lot at the time of the request.
 */
define('MEW_EVENT_STATUS_CLOSED_DUE_TO_LOCK', 6);

/**
 * This event request was cancelled.
 */
define('MEW_EVENT_STATUS_CANCELLED', 7);

/**
 * Taxonomy VID for the event classification.
 */
 define('MEW_VID_EVENT_CLASSIFICATION', 1);

/**
 * Taxonomy VID for the event classification.
 */
 define('MEW_VID_EVENT_STEPS', 19);

/**
 * Taxonomy VID for the event location.
 */
 define('MEW_VID_EVENT_LOCATION', 7);

/**
 * Taxonomy VID for the event audience.
 */
 define('MEW_VID_EVENT_AUDIENCE', 9);

/**
 * Taxonomy VID for the event revenue generated.
 */
 define('MEW_VID_REVENUE_GENERATED', 15);

/**
 * Taxonomy VID for the event information type.
 */
 define('MEW_VID_EVENT_INFORMATION_TYPE', 8);

/**
 * Taxonomy VID for the event publicity details.
 */
 define('MEW_VID_EVENT_PUBLICITY_DETAILS', 11);

/**
 * Taxonomy VID for the event designing material.
 */
 define('MEW_VID_EVENT_DESIGNING_MATERIAL', 16);

/**
 * Taxonomy VID for the event technical equipment details.
 */
 define('MEW_VID_EVENT_TECHNICAL_EQUIPMENT_DETAILS', 10);

/**
 * Taxonomy VID for the event reviewer classification.
 */
 define('MEW_VID_EVENT_REVIEWER_CLASSIFICATION', 17);

/**
 * Taxonomy VID for the event reviewer decision.
 */
 define('MEW_VID_EVENT_REVIEWER_DECISION', 18);

/**
 * Taxonomy TID for the review step completed.
 */
 define('MEW_REVIEW_STEP_COMPLETED', 134);

/**
 * Taxonomy TID for the review step confirm and reserve food services.
 */
 define('MEW_REVIEW_STEP_CONFIRM_AND_RESERVE_SERVICES', 121);

/**
 * Taxonomy TID for the review step confirm and reserve housing.
 */
 define('MEW_REVIEW_STEP_CONFIRM_AND_RESERVE_HOUSING', 120);

/**
 * Taxonomy TID for the review step confirm and reserve venue.
 */
 define('MEW_REVIEW_STEP_CONFIRM_AND_RESERVE_VENUE', 119);

/**
 * Taxonomy TID for the review step coordinator review / resolve conflicts / make decisions.
 */
 define('MEW_REVIEW_STEP_MAKE_DECISIONS', 117);

/**
 * Taxonomy TID for the review step release tentative hold.
 */
 define('MEW_REVIEW_STEP_RELEASE_HOLD', 118);

/**
 * Taxonomy TID for the review step review.
 */
 define('MEW_REVIEW_STEP_REVIEW', 132);

/**
 * Taxonomy TID for the review step usage fees.
 */
 define('MEW_REVIEW_STEP_USAGE_FEES', 133);

/**
 * Taxonomy TID for the review step venue available.
 */
 define('MEW_REVIEW_STEP_VENUE_AVAILABLE', 116);

/**
 * Taxonomy TID for the review decision approve.
 */
 define('MEW_REVIEW_DECISION_APPROVE', 115);

/**
 * Taxonomy TID for the review decision comment.
 */
 define('MEW_REVIEW_DECISION_COMMENT', 113);

/**
 * Taxonomy TID for the review decision deny.
 */
 define('MEW_REVIEW_DECISION_DENY', 114);

/**
 * Taxonomy TID for the review decision wave.
 */
 define('MEW_REVIEW_DECISION_WAVE', 135);

/**
 * Taxonomy TID for the review decision usage fee.
 */
 define('MEW_REVIEW_DECISION_USAGE_FEE', 136);

/**
 * Taxonomy TID for the review classification administrative accounting.
 */
 define('MEW_REVIEW_CLASSIFICATION_ADMINISTRATIVE_ACCOUNTING', 105);

/**
 * Taxonomy TID for the review classification event coordinator.
 */
 define('MEW_REVIEW_CLASSIFICATION_EVENT_COORDINATOR', 99);

/**
 * Taxonomy TID for the review classification facilities / custodial services.
 */
 define('MEW_REVIEW_CLASSIFICATION_FACILITIES', 104);

/**
 * Taxonomy TID for the review classification faculty advisor.
 */
 define('MEW_REVIEW_CLASSIFICATION_FACULTY_ADVISOR', 100);

/**
 * Taxonomy TID for the review classification food services.
 */
 define('MEW_REVIEW_CLASSIFICATION_FOOD_SERVICES', 108);

/**
 * Taxonomy TID for the review classification housing.
 */
 define('MEW_REVIEW_CLASSIFICATION_HOUSING', 107);

/**
 * Taxonomy TID for the review classification maintenance.
 */
 define('MEW_REVIEW_CLASSIFICATION_MAINTENANCE', 103);

/**
 * Taxonomy TID for the review classification purchasing / insurance.
 */
 define('MEW_REVIEW_CLASSIFICATION_PURCHASING', 106);

/**
 * Taxonomy TID for the review classification security / university police.
 */
 define('MEW_REVIEW_CLASSIFICATION_SECURITY', 102);

/**
 * Taxonomy TID for the review classification student services.
 */
 define('MEW_REVIEW_CLASSIFICATION_STUDENT_SERVICES', 101);

/**
 * Taxonomy TID for the review classification venue coordinator.
 */
 define('MEW_REVIEW_CLASSIFICATION_VENUE_COORDINATOR', 112);

/**
 * Taxonomy TID for the review classification manager.
 */
 define('MEW_REVIEW_CLASSIFICATION_SYSTEM_ADMINISTRATOR', 1);

/**
 * Taxonomy TID for the review classification manager.
 */
 define('MEW_REVIEW_CLASSIFICATION_MANAGER', 2);

/**
 * E-mail address for a failsafe venue/event coordinator.
 */
 define('MEW_REVIEW_CLASSIFICATION_FAILSAFE_COORDINATOR', 'shogan@mcneese.edu');

/**
 * Taxonomy TID for the event classification.
 */
 define('MEW_EVENT_CLASSIFICATION_STUDENT', 1);

/**
 * Taxonomy TID for the event classification.
 */
 define('MEW_EVENT_CLASSIFICATION_CAMPS', 2);

/**
 * Taxonomy TID for the event classification.
 */
 define('MEW_EVENT_CLASSIFICATION_FACULTY', 3);

/**
 * Taxonomy TID for the event classification.
 */
 define('MEW_EVENT_CLASSIFICATION_EXTERNAL', 4);



/**
 * Implements hook_permission().
 */
function mcneese_event_workflow_permission() {
  $permissions = array();
  $permissions['mcneese event workflow administer'] = array(
    'title' => t("Administer Event Workflow"),
    'description' => t("Grants permissions to administer event requests and workflow."),
  );

  $permissions['mcneese event workflow request'] = array(
    'title' => t("Request Event Workflow"),
    'description' => t("Grants permissions to make request events."),
  );

  $permissions['mcneese event workflow review'] = array(
    'title' => t("Review Event Workflow"),
    'description' => t("Grants permissions to review event requests."),
  );

  $permissions['mcneese event workflow manage'] = array(
    'title' => t("Manage Event Workflow"),
    'description' => t("Grants permissions to manage event requests."),
  );


  return $permissions;
}

/**
 * Implements hook_menu().
 */
function mcneese_event_workflow_menu() {
  $items = array();

  $items['events'] = array(
    'title' => "Event Requests Dashboard",
    'description' => "Event Dashboard",
    'page callback' => 'mcneese_event_workflow_management_page',
    'file' => 'mcneese_event_workflow_management_page.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/pages',
    'access callback' => 'mcneese_event_workflow_management_page_access',
    'tab_parent' => '',
    'tab_root' => '',
  );

  $items['events/create-0'] = array(
    'title' => "Request Event",
    'description' => "New Request",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcneese_event_workflow_event_create_0_form'),
    'file' => 'mcneese_event_workflow_event_create_page.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/pages',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('create'),
    'tab_parent' => 'events',
    'tab_root' => 'events',
  );

  $items['events/create-0/autocomplete/event_coordinator/email'] = array(
    'title' => "",
    'page callback' => 'mcneese_event_workflow_event_edit_0_autocomplete_event_coordinator_email',
    'file' => 'mcneese_event_workflow_autocomplete.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/includes',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('create'),
    'type' => MENU_CALLBACK,
  );

  $items['events/create-0/autocomplete/event_coordinator/name'] = array(
    'title' => "",
    'page callback' => 'mcneese_event_workflow_event_edit_0_autocomplete_event_coordinator_name',
    'file' => 'mcneese_event_workflow_autocomplete.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/includes',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('create'),
    'type' => MENU_CALLBACK,
  );

  $items['events/create-0/autocomplete/event_coordinator/phone'] = array(
    'title' => "",
    'page callback' => 'mcneese_event_workflow_event_edit_0_autocomplete_event_coordinator_phone',
    'file' => 'mcneese_event_workflow_autocomplete.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/includes',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('create'),
    'type' => MENU_CALLBACK,
  );

  // this is provided as a way to have the breadcrumb path simulate the 'view' despite not being in the url path.
  $items['events/edit-0/%'] = array(
    'title' => "View Request",
    'description' => "Edit Request",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcneese_event_workflow_event_edit_0_form', 2),
    'file' => 'mcneese_event_workflow_event_edit_page.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/pages',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('edit', 2),
    'tab_parent' => 'events',
    'tab_root' => 'events',
  );

  $items['events/edit-0/%/%'] = array(
    'title' => "Edit Request",
    'description' => "Edit Request",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcneese_event_workflow_event_edit_0_form', 2, 3),
    'file' => 'mcneese_event_workflow_event_edit_page.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/pages',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('edit', 2),
    'tab_parent' => 'events',
    'tab_root' => 'events',
  );

  $items['events/edit-0/autocomplete/event_coordinator/email'] = array(
    'title' => "",
    'page callback' => 'mcneese_event_workflow_event_edit_0_autocomplete_event_coordinator_email',
    'file' => 'mcneese_event_workflow_autocomplete.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/includes',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('edit'),
    'type' => MENU_CALLBACK,
  );

  $items['events/edit-0/autocomplete/event_coordinator/name'] = array(
    'title' => "",
    'page callback' => 'mcneese_event_workflow_event_edit_0_autocomplete_event_coordinator_name',
    'file' => 'mcneese_event_workflow_autocomplete.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/includes',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('edit'),
    'type' => MENU_CALLBACK,
  );

  $items['events/edit-0/autocomplete/event_coordinator/phone'] = array(
    'title' => "",
    'page callback' => 'mcneese_event_workflow_event_edit_0_autocomplete_event_coordinator_phone',
    'file' => 'mcneese_event_workflow_autocomplete.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/includes',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('edit'),
    'type' => MENU_CALLBACK,
  );

  #$items['events/edit-0/ctools/%/%'] = array(
  #  'title' => "Edit Request",
  #  'description' => "Make changes to an existing facilities and special event request form.",
  #  'page callback' => 'mcneese_event_workflow_event_edit_0_form_ctools',
  #  'page arguments' => array(3, 4),
  #  'file' => 'mcneese_event_workflow_event_edit_page.inc',
  #  'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/pages',
  #  'access callback' => 'mcneese_event_workflow_management_page_event_access',
  #  'access arguments' => array('edit', 3),
  #  'tab_parent' => 'events',
  #  'type' => MENU_CALLBACK,
  #);

  $items['events/reviewers-0'] = array(
    'title' => "Manage Reviewers",
    'description' => "Review Request",
    'page callback' => 'mcneese_event_workflow_event_reviewers_0_page',
    'file' => 'mcneese_event_workflow_event_reviewers_page.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/pages',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('reviewers'),
    'tab_parent' => 'events',
    'tab_root' => 'events',
  );

  $items['events/reviewers-0/list/%/%'] = array(
    'title' => "List Reviewers",
    'description' => "List Reviewers",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcneese_event_workflow_event_reviewers_0_form', 3, 4),
    'file' => 'mcneese_event_workflow_event_reviewers_page.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/pages',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('reviewers'),
    'tab_parent' => 'events/reviewers-0',
    'tab_root' => 'events/reviewers-0',
  );

  $items['events/reviewers-0/delete/%'] = array(
    'title' => "Delete Reviewer",
    'description' => "Delete Reviewer",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcneese_event_workflow_event_reviewers_0_delete_form', 3),
    'file' => 'mcneese_event_workflow_event_reviewers_page.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/pages',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('reviewers'),
    'tab_parent' => 'events/reviewers-0',
    'tab_root' => 'events/reviewers-0',
  );

  $items['events/reviewers-0/autocomplete/user_id'] = array(
    'title' => "",
    'page callback' => 'mcneese_event_workflow_event_reviewers_0_autocomplete_user_id',
    'file' => 'mcneese_event_workflow_autocomplete.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/includes',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('reviewers'),
    'type' => MENU_CALLBACK,
  );

  $items['events/reviewers-0/autocomplete/reviewer_classification'] = array(
    'title' => "",
    'page callback' => 'mcneese_event_workflow_event_reviewers_0_autocomplete_reviewer_classification',
    'file' => 'mcneese_event_workflow_autocomplete.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/includes',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('reviewers'),
    'type' => MENU_CALLBACK,
  );

  $items['events/review-0'] = array(
    'title' => "Review Requests",
    'description' => "Review Request",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcneese_event_workflow_event_review_0_page'),
    'file' => 'mcneese_event_workflow_event_review_page.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/pages',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('review'),
    'tab_parent' => 'events',
    'tab_root' => 'events',
  );

  $items['events/review-0/%'] = array(
    'title' => "Review Requests",
    'description' => "Review Request",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcneese_event_workflow_event_review_0_page', 2),
    'file' => 'mcneese_event_workflow_event_review_page.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/pages',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('review'),
    'tab_parent' => 'events',
    'tab_root' => 'events',
  );

  $items['events/delete-0/%'] = array(
    'title' => "Delete Request",
    'description' => "Delete Request",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcneese_event_workflow_event_delete_0_form', 2),
    'file' => 'mcneese_event_workflow_event_delete_page.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/pages',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('delete', 2),
    'tab_parent' => 'events',
    'tab_root' => 'events',
  );

  $items['events/cancel-0/%'] = array(
    'title' => "Cancel Request",
    'description' => "Cancel Request",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcneese_event_workflow_event_cancel_0_form', 2),
    'file' => 'mcneese_event_workflow_event_cancel_page.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/pages',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('cancel', 2),
    'tab_parent' => 'events',
    'tab_root' => 'events',
  );

  $items['events/uncancel-0/%'] = array(
    'title' => "Cancel Request",
    'description' => "Uncancel Request",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcneese_event_workflow_event_uncancel_0_form', 2),
    'file' => 'mcneese_event_workflow_event_cancel_page.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/pages',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('uncancel', 2),
    'tab_parent' => 'events',
    'tab_root' => 'events',
  );

  $items['events/list-0'] = array(
    'title' => "List Requests",
    'description' => "List Requests",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcneese_event_workflow_event_list_0_page'),
    'file' => 'mcneese_event_workflow_event_list_page.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/pages',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('list'),
    'tab_parent' => 'events',
    'tab_root' => 'events',
  );

  $items['events/list-0/%'] = array(
    'title' => "List Requests",
    'description' => "List Requests",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcneese_event_workflow_event_list_0_page', 2),
    'file' => 'mcneese_event_workflow_event_list_page.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/pages',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('list'),
    'tab_parent' => 'events',
    'tab_root' => 'events',
  );

  $items['events/search-0'] = array(
    'title' => "Search Requests",
    'description' => "Search Requests",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcneese_event_workflow_event_search_0_form'),
    'file' => 'mcneese_event_workflow_event_search_page.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/pages',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('search'),
    'tab_parent' => 'events',
    'tab_root' => 'events',
  );

  $items['events/view-0/%'] = array(
    'title' => "View Request",
    'description' => "View Request",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcneese_event_workflow_event_view_0_page', 2),
    'file' => 'mcneese_event_workflow_event_view_page.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/pages',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('view', 2),
    'tab_parent' => 'events/list-0',
    'tab_root' => 'events/list-0',
  );

  $items['events/view-0/%/%'] = array(
    'title' => "View Request",
    'description' => "View Request",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcneese_event_workflow_event_view_0_page', 2, 3),
    'file' => 'mcneese_event_workflow_event_view_page.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/pages',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('view', 2),
    'tab_parent' => 'events/list-0',
    'tab_root' => 'events/list-0',
  );

  $items['events/pdf-0/%/%'] = array(
    'title' => "Request PDF",
    'description' => "Download Request PDF",
    'page callback' => 'mcneese_event_workflow_event_pdf_0_page',
    'page arguments' => array(2, 3),
    'file' => 'mcneese_event_workflow_event_view_page.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/pages',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('view', 2),
    'tab_parent' => 'events/list-0',
    'tab_root' => 'events/list-0',
    'type' => MENU_CALLBACK,
  );

  $items['events/history-0/%'] = array(
    'title' => "Event History",
    'description' => "Event History",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcneese_event_workflow_event_history_0_form', 2),
    'file' => 'mcneese_event_workflow_event_history_page.inc',
    'file path' => drupal_get_path('module', 'mcneese_event_workflow') . '/pages',
    'access callback' => 'mcneese_event_workflow_management_page_event_access',
    'access arguments' => array('history', 2),
    'tab_parent' => 'events',
    'tab_root' => 'events',
  );

  return $items;
}

/**
 * Access callback for event workflow management page.
 *
 * @param string $operation
 *   (optional) When specified, performs access check based on operation.
 * @param int $event_id
 *   (optional) When specified, performs access check based the provided id.
 *   Some operations require this to return TRUE under certain circumstances.
 *
 * @param bool
 *   TRUE on access granted, FALSE otherwise.
 */
function mcneese_event_workflow_management_page_event_access($operation = NULL, $event_id = NULL) {
  global $user;

  $request_status = array(
    MEW_EVENT_STATUS_LOCKED,
    MEW_EVENT_STATUS_UNLOCKED,
    MEW_EVENT_STATUS_CLOSED_ACCEPTED,
    MEW_EVENT_STATUS_CLOSED_DENIED,
    MEW_EVENT_STATUS_CLOSED_UNAVAILABLE,
    MEW_EVENT_STATUS_CLOSED_UNAVAILABLE,
    MEW_EVENT_STATUS_CANCELLED,
  );

  $manager = user_access('mcneese event workflow manage');
  $reviewer = user_access('mcneese event workflow review');
  $requester = user_access('mcneese event workflow request');

  if ($operation == 'create') {
    if ($requester) {
      return TRUE;
    }
  }
  elseif ($operation == 'edit') {
    $edit_request_status = array(
      MEW_EVENT_STATUS_UNLOCKED,
    );

    if ($manager) {
      try {
        $query = db_select('mew_event_requests', 'mer');

        $query->innerjoin('mew_current_top', 'mct', 'mer.id = mct.event_id');
        $query->innerjoin('mew_field_top_status', 'mfts', 'mct.event_id = mfts.event_id AND mct.status = mfts.revision AND mfts.delta = 0');

        // $query->countQuery() does not appear to be functioning as expected, so manually count.
        $query->addExpression('count(mer.id)');

        $query->condition('mer.id', $event_id);
        $query->condition('mfts.value', $edit_request_status, 'IN');

        $result = $query->execute()->fetchField();

        if ($result > 0) return TRUE;

        return FALSE;
      }
      catch (Exception $ex) {
        cf_error::on_exception($ex);

        return FALSE;
      }
    }
    elseif ($requester) {
      if (is_null($event_id)) return FALSE;

      try {
        $query = db_select('mew_event_requests', 'mer');

        $query->innerjoin('mew_current_top', 'mct', 'mer.id = mct.event_id');
        $query->innerjoin('mew_field_top_status', 'mfts', 'mct.event_id = mfts.event_id AND mct.status = mfts.revision AND mfts.delta = 0');

        // $query->countQuery() does not appear to be functioning as expected, so manually count.
        $query->addExpression('count(mer.id)');

        $query->condition('mer.id', $event_id);
        $query->condition('mer.user_id', $user->uid);
        $query->condition('mfts.value', $edit_request_status, 'IN');

        $result = $query->execute()->fetchField();

        if ($result > 0) return TRUE;

        return FALSE;
      }
      catch (Exception $ex) {
        cf_error::on_exception($ex);

        return FALSE;
      }
    }
  }
  elseif ($operation == 'view') {
    if ($manager) {
      try {
        $query = db_select('mew_event_requests', 'mer');

        $query->innerjoin('mew_current_top', 'mct', 'mer.id = mct.event_id');
        $query->innerjoin('mew_field_top_status', 'mfts', 'mct.event_id = mfts.event_id AND mct.status = mfts.revision AND mfts.delta = 0');

        // $query->countQuery() does not appear to be functioning as expected, so manually count.
        $query->addExpression('count(mer.id)');

        $query->condition('mer.id', $event_id);
        $query->condition('mfts.value', MEW_EVENT_STATUS_DELETED, '<>');

        $result = $query->execute()->fetchField();

        if ($result > 0) return TRUE;

        return FALSE;
      }
      catch (Exception $ex) {
        cf_error::on_exception($ex);

        return FALSE;
      }
    }
    elseif ($reviewer) {
      if (is_null($event_id)) {
        return TRUE;
      }
      else {
        // do a quick test to see if the reviewer is also the requester, if so, then grant access when $ignore_decisions
        if ($requester) {
          $query = db_select('mew_event_requests', 'mer');

          $query->innerjoin('mew_current_top', 'mct', 'mer.id = mct.event_id');
          $query->innerjoin('mew_field_top_status', 'mfts', 'mct.event_id = mfts.event_id AND mct.status = mfts.revision AND mfts.delta = 0');

          // $query->countQuery() does not appear to be functioning as expected, so manually count.
          $query->addExpression('count(mer.id)');

          $query->condition('mer.id', $event_id);
          $query->condition('mer.user_id', $user->uid);
          $query->condition('mfts.value', $request_status, 'IN');

          $result = $query->execute()->fetchField();

          if ($result > 0) return TRUE;
        }

        return mcneese_event_workflow_management_page_event_reviewer_access($user, $event_id, TRUE);
      }
    }
    elseif ($requester) {
      if (is_null($event_id)) return FALSE;

      try {
        $query = db_select('mew_event_requests', 'mer');

        $query->innerjoin('mew_current_top', 'mct', 'mer.id = mct.event_id');
        $query->innerjoin('mew_field_top_status', 'mfts', 'mct.event_id = mfts.event_id AND mct.status = mfts.revision AND mfts.delta = 0');

        // $query->countQuery() does not appear to be functioning as expected, so manually count.
        $query->addExpression('count(mer.id)');

        $query->condition('mer.id', $event_id);
        $query->condition('mer.user_id', $user->uid);
        $query->condition('mfts.value', $request_status, 'IN');

        $result = $query->execute()->fetchField();

        if ($result > 0) return TRUE;

        return FALSE;
      }
      catch (Exception $ex) {
        cf_error::on_exception($ex);

        return FALSE;
      }
    }
  }
  elseif ($operation == 'list') {
    if ($requester || $reviewer || $manager) {
      return TRUE;
    }
  }
  elseif ($operation == 'search') {
    if ($requester || $reviewer || $manager) {
      return TRUE;
    }
  }
  elseif ($operation == 'reviewers') {
    if ($manager) {
      return TRUE;
    }
  }
  elseif ($operation == 'review') {
    if (is_null($event_id)) {
      if ($reviewer) {
        return TRUE;
      }
    }
    else {
      return mcneese_event_workflow_management_page_event_reviewer_access($user, $event_id);
    }
  }
  elseif ($operation == 'comment') {
    // @todo: currently disabled feature. Enable if such functionality is requested.
    return FALSE;

    if ($manager) {
      return TRUE;
    }

    if (!is_null($event_id)) {
      return mcneese_event_workflow_management_page_event_reviewer_access($user, $event_id, TRUE);
    }
  }
  elseif ($operation == 'log') {
    if ($manager) {
      return TRUE;
    }

    if ($reviewer) {
      if (is_null($event_id)) {
        return TRUE;
      }
      else {
        return mcneese_event_workflow_management_page_event_reviewer_access($user, $event_id, TRUE);
      }
    }
  }
  elseif ($operation == 'delete') {
    if ($manager) {
      return TRUE;
    }
  }

  elseif ($operation == 'cancel') {
    $cancellable_status_normal = array(
      MEW_EVENT_STATUS_UNLOCKED,
    );

    $cancellable_status_admin = array(
      MEW_EVENT_STATUS_LOCKED,
      MEW_EVENT_STATUS_UNLOCKED,
    );

    // if the user is the venue coordinator, then allow them to cancel an event at any point in the process.
    try {
      $query = db_select('mew_event_requests', 'mer');

      $query->innerjoin('mew_current_top', 'mct', 'mer.id = mct.event_id');
      $query->innerjoin('mew_field_top_status', 'mfts', 'mct.event_id = mfts.event_id AND mct.status = mfts.revision AND mfts.delta = 0');

      $query->innerjoin('mew_current_venue_coordinator', 'mcvc', 'mer.id = mcvc.event_id');
      $query->innerjoin('mew_field_venue_coordinator_user_id', 'mfvcui', 'mcvc.event_id = mfvcui.event_id AND mcvc.user_id = mfvcui.revision AND mfvcui.delta = 0');

      // $query->countQuery() does not appear to be functioning as expected, so manually count.
      $query->addExpression('count(mer.id)');

      $query->condition('mer.id', $event_id);
      $query->condition('mfts.value', $cancellable_status_admin, 'IN');
      $query->condition('mfvcui.value', $user->uid);

      $result = $query->execute()->fetchField();

      if ($result > 0) return TRUE;
    }
    catch (Exception $ex) {
      cf_error::on_exception($ex);
      return FALSE;
    }

    if ($manager || $requester) {
      try {
        $query = db_select('mew_event_requests', 'mer');

        $query->innerjoin('mew_current_top', 'mct', 'mer.id = mct.event_id');
        $query->innerjoin('mew_field_top_status', 'mfts', 'mct.event_id = mfts.event_id AND mct.status = mfts.revision AND mfts.delta = 0');

        // $query->countQuery() does not appear to be functioning as expected, so manually count.
        $query->addExpression('count(mer.id)');

        $query->condition('mer.id', $event_id);

        if ($requester && !$manager) {
          $query->condition('mer.user_id', $user->uid);
          $query->condition('mfts.value', $cancellable_status_normal, 'IN');
        }
        else {
          $query->condition('mfts.value', $cancellable_status_admin, 'IN');
        }

        $result = $query->execute()->fetchField();

        if ($result > 0) return TRUE;
      }
      catch (Exception $ex) {
        cf_error::on_exception($ex);
        return FALSE;
      }
    }
  }
  elseif ($operation == 'uncancel') {
    $uncancellable_status = array(
      MEW_EVENT_STATUS_CANCELLED,
    );

    // if the user is the venue coordinator, then allow them to cancel an event at any point in the process.
    try {
      $query = db_select('mew_event_requests', 'mer');

      $query->innerjoin('mew_current_top', 'mct', 'mer.id = mct.event_id');
      $query->innerjoin('mew_field_top_status', 'mfts', 'mct.event_id = mfts.event_id AND mct.status = mfts.revision AND mfts.delta = 0');

      $query->innerjoin('mew_current_venue_coordinator', 'mcvc', 'mer.id = mcvc.event_id');
      $query->innerjoin('mew_field_venue_coordinator_user_id', 'mfvcui', 'mcvc.event_id = mfvcui.event_id AND mcvc.user_id = mfvcui.revision AND mfvcui.delta = 0');

      // $query->countQuery() does not appear to be functioning as expected, so manually count.
      $query->addExpression('count(mer.id)');

      $query->condition('mer.id', $event_id);
      $query->condition('mfts.value', $uncancellable_status, 'IN');
      $query->condition('mfvcui.value', $user->uid);

      $result = $query->execute()->fetchField();

      if ($result > 0) return TRUE;
    }
    catch (Exception $ex) {
      cf_error::on_exception($ex);
      return FALSE;
    }

    if ($manager) {
      try {
        $query = db_select('mew_event_requests', 'mer');

        $query->innerjoin('mew_current_top', 'mct', 'mer.id = mct.event_id');
        $query->innerjoin('mew_field_top_status', 'mfts', 'mct.event_id = mfts.event_id AND mct.status = mfts.revision AND mfts.delta = 0');

        // $query->countQuery() does not appear to be functioning as expected, so manually count.
        $query->addExpression('count(mer.id)');

        $query->condition('mer.id', $event_id);
        $query->condition('mfts.value', $uncancellable_status, 'IN');

        $result = $query->execute()->fetchField();

        if ($result > 0) return TRUE;
      }
      catch (Exception $ex) {
        cf_error::on_exception($ex);

        return FALSE;
      }
    }
  }
  elseif ($operation == 'history') {
    if ($manager) {
      return TRUE;
    }
  }

  return FALSE;
}


/**
 * Check to see if a given user is allowed to review a given event.
 *
 * @param object $user
 *   User to check if is a valid reviewer of the given event.
 * @param int $event_id
 *   ID of the event to check review access for.
 * @param bool $ignore_decisions
 *   (optional) When TRUE, will not perform additional checks to see if the
 *   current user has already reviewed the event. When FALSE, then validation
 *   will be performed based on whether or not the reviewer has already
 *   reviewed the event for the current step.
 * @param bool
 *   TRUE on access granted, FALSE otherwise.
 */
function mcneese_event_workflow_management_page_event_reviewer_access($user, $event_id, $ignore_decisions = FALSE) {
  if (!is_object($user)) {
    cf_error::invalid_object('user');
    return FALSE;
  }

  if (!cf_is_integer($event_id)) {
    cf_error::invalid_integer('event_id');
    return FALSE;
  }

  if (!is_bool($ignore_decisions)) {
    cf_error::invalid_bool('ignore_decisions');
    return FALSE;
  }

  try {
    $query = db_select('mew_event_requests', 'mer');

    $query->innerjoin('mew_current_top', 'mct', 'mer.id = mct.event_id');

    $query->innerjoin('mew_field_top_status', 'mfts', 'mct.event_id = mfts.event_id AND mct.status = mfts.revision AND mfts.delta = 0');
    $query->innerjoin('mew_field_top_step', 'mftsp', 'mct.event_id = mftsp.event_id AND mct.step = mftsp.revision AND mftsp.delta = 0');

    // $query->countQuery() does not appear to be functioning as expected, so manually count.
    $query->addExpression('count(mer.id)');

    $query->condition('mfts.value', MEW_EVENT_STATUS_DELETED, '<>');
    $query->condition('mfts.event_id', $event_id);

    $query->innerjoin('mew_current_event_coordinator', 'mcec', 'mer.id = mcec.event_id');
    $query->innerjoin('mew_field_event_coordinator_classification', 'mfecc', 'mcec.event_id = mfecc.event_id AND mcec.classification = mfecc.revision AND mfecc.delta = 0');

    $query->innerjoin('mew_current_venue_coordinator', 'mcvc', 'mer.id = mcvc.event_id');
    $query->innerjoin('mew_field_venue_coordinator_user_id', 'mfvcui', 'mcvc.event_id = mfvcui.event_id AND mcvc.user_id = mfvcui.revision AND mfvcui.delta = 0');

    $or = db_or();

    if (!$ignore_decisions) {
      $show_status = array(
        MEW_EVENT_STATUS_LOCKED,
        MEW_EVENT_STATUS_UNLOCKED,
      );

      $show_step = array(
        MEW_REVIEW_STEP_VENUE_AVAILABLE,
        MEW_REVIEW_STEP_MAKE_DECISIONS
      );

      $show_decision = array(
        MEW_REVIEW_DECISION_APPROVE,
        MEW_REVIEW_DECISION_DENY
      );

      $review_query = db_select('mew_field_review_review', 'mfrr');
      $review_query->innerjoin('mew_current_review', 'mcr', 'mfrr.event_id = mcr.event_id and mfrr.revision = mcr.review');

      $review_query->addfield('mfrr', 'step', 'step');

      $review_query->where('mfrr.event_id = mftsp.event_id');
      $review_query->condition('mfrr.user_id', $user->uid);
      $review_query->condition('mfrr.step', $show_step, 'IN');
      $review_query->condition('mfrr.decision', $show_decision, 'IN');
      $review_query->distinct();

      $and = db_and();
      $and->condition('mfts.value', $show_status, 'IN');
      $and->condition('mftsp.value', $show_step, 'IN');
      $and->condition('mftsp.value', $review_query, 'NOT IN');
      $and->condition('mfvcui.value', $user->uid);
      $or->condition($and);
    }
    else {
      $or->condition('mfvcui.value', $user->uid);
    }

    $show_status = array(
      MEW_EVENT_STATUS_LOCKED,
    );

    $show_step = array(
      MEW_REVIEW_STEP_REVIEW,
      MEW_REVIEW_STEP_USAGE_FEES,
    );

    if (!$ignore_decisions) {
      $show_decision = array(
        MEW_REVIEW_DECISION_APPROVE,
        MEW_REVIEW_DECISION_DENY
      );

      # Get all of the existing reviews
      $review_query = db_select('mew_field_review_review', 'r_mfrr');
      $review_query->innerjoin('mew_review_classifications', 'r_mrc', 'r_mfrr.id = r_mrc.review_id');
      $review_query->innerjoin('mew_current_review', 'r_mcr', 'r_mfrr.event_id = r_mcr.event_id and r_mfrr.revision = r_mcr.review');

      $review_query->addfield('r_mrc', 'classification', 'classification');

      $review_query->where('r_mfrr.event_id = mer.id AND r_mfrr.step = mftsp.value');
      $review_query->condition('r_mfrr.step', $show_step, 'IN');
      $review_query->condition('r_mfrr.decision', $show_decision, 'IN');
      $review_query->distinct();

      # Get the current users reviewer classifications for a given event.
      $classifications_query = db_select('mew_reviewers', 'c_mr');

      $classifications_query->addfield('c_mr', 'reviewer_classification', 'reviewer_classification');

      $classifications_query->where('c_mr.event_classification = mfecc.value AND c_mr.review_step = mftsp.value');
      $classifications_query->condition('c_mr.user_id', $user->uid);
      $classifications_query->condition('c_mr.reviewer_classification', $review_query, 'NOT IN');
      $classifications_query->range(0, 1);

      # Check to see if the user can review.
      # The user does not have to be the user who reviewed for a given reviewer_classification, but he must be a valid user for the event_classification and review step.
      $can_review_query = db_select('mew_reviewers', 'c_mr_2');

      $can_review_query->addfield('c_mr_2', 'user_id', 'user_id');

      $can_review_query->where('c_mr_2.event_classification = mfecc.value AND c_mr_2.review_step = mftsp.value');
      $can_review_query->condition('c_mr_2.user_id', $user->uid);
      $can_review_query->distinct();

      $and = db_and();
      $and->condition(1, $classifications_query, 'NOT IN');
      $and->condition($user->uid, $can_review_query, 'IN');
      $and->condition('mfts.value', $show_status, 'IN');

      $or->condition($and);
    }
    else {
      # Check to see if the user can review.
      $can_review_query = db_select('mew_reviewers', 'c_mr_2');

      $can_review_query->addfield('c_mr_2', 'user_id', 'user_id');

      $can_review_query->where('c_mr_2.event_classification = mfecc.value AND c_mr_2.review_step = mftsp.value');
      $can_review_query->condition('c_mr_2.user_id', $user->uid);
      $can_review_query->distinct();

      $and = db_and();
      $and->condition('mfts.value', $show_status, 'IN');
      $and->condition('mftsp.value', $show_step, 'IN');
      $and->condition($user->uid, $can_review_query, 'IN');
      $or->condition($and);
    }

    $query->condition($or);

    $result = $query->execute()->fetchField();

    if ($result > 0) return TRUE;

    return FALSE;
  }
  catch (Exception $ex) {
    if (class_exists('cf_error')) {
      cf_error::on_query_execution($ex);
    }

    return FALSE;
  }

  return FALSE;
}

/**
 * Access callback for event workflow management page.
 *
 * @param bool
 *   TRUE on access granted, FALSE otherwise.
 */
function mcneese_event_workflow_management_page_access() {
  if (user_access('mcneese event workflow administer') || user_access('mcneese event workflow request') || user_access('mcneese event workflow review') || user_access('mcneese event workflow manage')) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Implements hook_cronapi().
 */
function mcneese_event_workflow_cronapi() {
  $items = array();

  $items['mcneese_event_workflow_oracle_recache'] = array(
    'title' => t("Recreate Oracle Cache"),
    'callback' => 'mcneese_event_workflow_oracle_recache_cron',
    'callback arguments' => array(),
    'enabled' => FALSE,
  );

  return $items;
}

/**
 * Implements hook_mail().
 */
function mcneese_event_workflow_mail($key, &$message, $params) {
  global $base_url;

  $language = $message['language'];
  $headers = array();
  $subject = '';

  $headers['MIME-Version'] = '1.0';
  $headers['X-Mailer'] = 'McNeese Event Workflow System';
  $headers['Date'] = date('r', REQUEST_TIME);
  $headers['Content-Transfer-Encoding'] = '8Bit';

  $boundary = hash('sha256', drupal_random_key());
  $headers['Content-Type'] = 'multipart/mixed; boundary="' . $boundary . '"';

  $body = '--' . $boundary . "\n";
  $body .= 'Content-Type: text/plain; charset=UTF-8' . "\n\n";

  if ($key == 'event_request_alert') {
    $headers['Message-ID'] = '<';
    $headers['Message-ID'] .= drupal_random_key(12);
    $headers['Message-ID'] .= '.' . REQUEST_TIME;
    $headers['Message-ID'] .= '@';
    $headers['Message-ID'] .= 'mcneese_event_request';
    $headers['Message-ID'] .= '>';

    $headers['Keywords'] = 'McNeese, Event Request, Review';

    $subject = 'McNeese Event Request: ' . $params['event_id'] . ' - ' . $params['event_title'];

    if (!empty($params['title_suffix'])) {
      $subject .= ' - ' . $params['title_suffix'];
    }

    $body .= $params['content'] . "\n";

    $body .= "\n";
    $body .= "Event URL:\n - " . $base_url . '/events/view-0/' . $params['event_id'] . "\n\n";

    $body .= "\n";
    $body .= "This e-mail was generated on:\n - " . date("Y/m/d h:i:s a T", REQUEST_TIME) . "\n\n";

    // add PDF attachment
    if (!empty($params['filename'])) {
      foreach ($params['filename'] as $filename) {
        $file_path = 'private://event_requests/local/';

        $body .= "\n" . '--' . $boundary . "\n";
        $body .= 'Content-Type: application/pdf; name=' . $filename . "\n";
        $body .= 'Content-Disposition: attachment; filename=' . $filename . "\n";
        $body .= 'Content-Transfer-Encoding: base64' . "\n\n";
        $body .= chunk_split(base64_encode(file_get_contents($file_path . $filename))) . "\n";
      }
    }
  }
  else {
    return;
  }

  $body .= '--' . $boundary . "--\n";

  foreach ($headers as $header_name => $header_value) {
    $message['headers'][$header_name] = $header_value;
  }

  $message['subject'] = $subject;
  $message['body'] = array($body);
}

/**
 * Helper function to load files related to this project.
 *
 * @param int $id
 *   The number associated with the file to include.
 */
function mcneese_event_workflow_include($id) {
  if (!is_numeric($id)) {
    cf_error::invalid_number('id');
    return;
  }

  $module_path = drupal_get_path('module', 'mcneese_event_workflow');

  if ($id == 0) {
    require_once($module_path . '/includes/mcneese_event_workflow_table.inc');
  }
  elseif ($id == 1) {
    require_once($module_path . '/includes/mcneese_event_workflow_event_structure.inc');
  }
  elseif ($id == 2) {
    require_once($module_path . '/includes/mcneese_event_workflow_event_validation.inc');
  }
  elseif ($id == 3) {
    require_once($module_path . '/includes/mcneese_event_workflow_autocomplete.inc');
  }
  elseif ($id == 4) {
    require_once($module_path . '/includes/mcneese_event_workflow_list_options.inc');
  }
  elseif ($id == 5) {
    require_once($module_path . '/pages/mcneese_event_workflow_event_cancel_page.inc');
  }
  elseif ($id == 6) {
    require_once($module_path . '/includes/mcneese_event_workflow_workflow.inc');
  }
}

/**
 * Performs a select query.
 *
 * @param string $query
 *   A query string to process.
 * @param array $arguments
 *   (optional) An array of arguments
 *
 * @return array|bool
 *   An array containing the query results.
 *   FALSE is returned on error.
 */
function mcneese_event_workflow_oracle_select($query, $arguments = array()) {
  if (!is_string($query)) {
    cf_error::invalid_string('query');

    return FALSE;
  }

  if (!is_array($arguments)) {
    cf_error::invalid_array('arguments');

    return FALSE;
  }

  $results = array();

  try {
    $conn = Database::getConnection('default', 'oracle');

    $results = (array) $conn->oracleQuery($query, $arguments)->fetchAll();
  } catch (Exception $ex) {
    cf_error::on_exception($ex);

    return FALSE;
  }

  return $results;
}

/**
 * Returns a list of columns defined in the venue list table.
 *
 * @return array|bool
 *   An array containing the column names.
 *   FALSE is returned on error.
 *
 * @see: mcneese_event_workflow_oracle_select()
 */
function mcneese_event_workflow_load_venue_detail_columns() {
  $cache_id = __function__;
  $columns = &drupal_static($cache_id, NULL);
  if (is_array($columns)) {
    return $columns;
  }

  if ($cache = cache_get($cache_id)){
    return $cache->data;
  }

  $columns = array();
  $rows = mcneese_event_workflow_oracle_select('select * from ucs.msu_venue_detail where rownum = 1');

  // determine columns names by selecting the first
  if (!empty($rows)) {
    $row = array_pop($rows);
    foreach ($row as $key => &$value) {
      // oracle returns duplicate/redundant data in numeric rows.
      if (is_numeric($key)) continue;

      if (!array_key_exists($key, $columns)) {
        $columns[] = $key;
      }
    }
  }

  if (empty($columns)) return FALSE;

  cache_set($cache_id, $columns, 'cache', CACHE_PERMANENT);

  return $columns;
}

/**
 * Returns a list of columns defined in the venue list table.
 *
 * @return array|bool
 *   An array containing the column names.
 *   FALSE is returned on error.
 *
 * @see: mcneese_event_workflow_oracle_select()
 */
function mcneese_event_workflow_load_venue_list_columns() {
  $cache_id = __function__;
  $columns = &drupal_static($cache_id, NULL);
  if (is_array($columns)) {
    return $columns;
  }

  if ($cache = cache_get($cache_id)){
    return $cache->data;
  }

  $columns = array();
  $rows = mcneese_event_workflow_oracle_select('select * from ucs.msu_venue_list where rownum = 1');

  // determine columns names by selecting the first row.
  if (!empty($rows)) {
    $row = array_pop($rows);
    foreach ($row as $key => &$value) {
      // oracle returns duplicate/redundant data in numeric rows.
      if (is_numeric($key)) continue;

      if (!array_key_exists($key, $columns)) {
        $columns[] = $key;
      }
    }
  }

  if (empty($columns)) return FALSE;

  cache_set($cache_id, $columns, 'cache', CACHE_PERMANENT);

  return $columns;
}

/**
 * Returns a list of buildings available.
 *
 * @param string|null $column
 *   (optional) when specified, only load a single, specific, column.
 *   Note: ucs.msu_venue_list calls the building location 'category', so use
 *  'category' for the 'location' column.
 * @param bool $column
 *   (optional) When specified, only load distinct results.
 *
 * @return array|bool
 *   An array containing the basic building information.
 *   FALSE is returned on error.
 *
 * @see: mcneese_event_workflow_load_venue_list_columns()
 * @see: mcneese_event_workflow_oracle_select()
 */
function mcneese_event_workflow_load_buildings_list($column = NULL, $distinct = FALSE) {
  if (!is_null($column) && !is_string($column)) {
    cf_error::invalid_string('column');
    return FALSE;
  }

  if (!is_bool($distinct)) {
    cf_error::invalid_bool('distinct');
    return FALSE;
  }

  $cache_id = __function__;
  $cache_expire = '+1 day';

  if (!empty($column)) {
    $cache_id .= '_' . $column;
  }

  if ($distinct) {
    $cache_id .= '_distinct';
  }

  $items = &drupal_static($cache_id, NULL);
  if (is_array($items)) {
    return $items;
  }

  if ($cache = cache_get($cache_id)){
    return $cache->data;
  }

  $columns = '*';
  if (!empty($column)) {
    // sanitize string by only allowing 'word' characters.
    $columns = preg_replace('/\W*/i', '', $column);
  }

  if ($distinct) {
    $columns = 'distinct (' . $columns . ')';
  }

  $items = array();
  $rows = (array) mcneese_event_workflow_oracle_select('select ' . $columns . ' from ucs.msu_venue_list');

  if (empty($column)) {
    foreach ($rows as &$row) {
      $item = array();

      if (is_array($row)) {
        foreach ($row as $key => &$value) {
          // oracle returns duplicate/redundant data in numeric rows.
          if (is_numeric($key)) continue;

          $item[$key] = $value;
        }
      }

      $items[] = $item;
    }
  }
  else {
    // return a single depth array when there is only 1 column being selected.
    foreach ($rows as &$row) {
      if (is_array($row)) {
        foreach ($row as $key => &$value) {
          // oracle returns duplicate/redundant data in numeric rows.
          if (is_numeric($key)) continue;

          $items[] = $value;
        }
      }
    }
  }

  if (empty($items)) return FALSE;

  $reset_cache_interval = new DateTime($cache_expire);
  cache_set($cache_id, $items, 'cache', $reset_cache_interval->getTimestamp());

  return $items;
}

 /**
 * Returns a list of buildings available.
 *
 * Note: ucs.msu_venue_list calls the building location 'category'.
 *
 * @param string|null $location
 *   (optional) when specified, load all buildings associated with a location.
 * @param string|null $building_code
 *   (optional) when specified, load all buildings associated with a building_code.
 * @param string|null $room_number
 *   (optional) when specified, load all buildings associated with a room_number.
 *
 * @return array|bool
 *   An array containing the detailed building information.
 *   FALSE is returned on error.
 *
 * @see: mcneese_event_workflow_load_buildings_list()
 * @see: mcneese_event_workflow_load_venue_list_columns()
 * @see: mcneese_event_workflow_oracle_select()
 */
function mcneese_event_workflow_load_buildings($location = NULL, $building_code = NULL, $room_number = NULL) {
  if (!is_null($location) && !is_string($location)) {
    cf_error::invalid_string('location');
    return FALSE;
  }

  if (!is_null($building_code) && !is_string($building_code)) {
    cf_error::invalid_string('building_code');
    return FALSE;
  }

  if (!is_null($room_number) && !is_string($room_number)) {
    cf_error::invalid_string('room_number');
    return FALSE;
  }

  $cache_id = __function__;
  $cache_expire = '+1 day';
  $load_details = FALSE;

  if (!empty($location)) {
    $cache_id .= '_' . $location;
  }

  if (!empty($building_code)) {
    $load_details = TRUE;
    $cache_id .= '_' . $building_code;
  }

  if (!empty($room_number)) {
    $load_details = TRUE;
    $cache_id .= '_' . $room_number;
  }

  $items = &drupal_static($cache_id, NULL);
  if (is_array($items)) {
    return $items;
  }

  if ($cache = cache_get($cache_id)){
    return $cache->data;
  }

  $where = '';
  if ($load_details) {
    $where .= ' where mvd.category is not NULL';

    if (!empty($location)) {
      // sanitize string by only allowing 'word' characters.
      $sanitized_location = preg_replace('/\W*/i', '', $location);

      $where .= ' AND mvd.category = \'' . $sanitized_location . '\'';
    }

    if (!empty($building_code)) {
      // sanitize string by only allowing 'word' characters.
      $sanitized_building_code = preg_replace('/\W*/i', '', $building_code);

      $where .= ' AND mvd.building_code = \'' . $sanitized_building_code . '\'';
    }

    if (!empty($room_number)) {
      // sanitize string by only allowing 'word' characters.
      $sanitized_room_number = preg_replace('/\W*/i', '', $room_number);

      $where .= ' AND mvd.room_number = \'' . $sanitized_room_number . '\'';
    }
  }
  else {
    $where .= ' where mvl.category is not NULL';

    if (!empty($location)) {
      // sanitize string by only allowing 'word' characters.
      $sanitized_location = preg_replace('/\W*/i', '', $location);

      $where .= ' AND mvl.category = \'' . $sanitized_location . '\'';
    }
  }

  $items = array();
  if ($load_details) {
    $join = ' inner join ucs.msu_venue_list mvl on (mvl.category = mvd.category and mvl.building_code = mvd.building_code and mvl.room_number = mvd.room_number)';

    $select = 'mvd.*';
    $select .= ', mvl.building_desc as building_desc';
    $select .= ', mvl.room_desc as room_desc';

    $rows = mcneese_event_workflow_oracle_select('select ' . $select . ' from ucs.msu_venue_detail mvd' . $join . $where);
  }
  else {
    $select = 'mvl.*';

    $rows = mcneese_event_workflow_oracle_select('select ' . $select . ' from ucs.msu_venue_list mvl' . $where);
  }

  if ($rows === FALSE) {
    return FALSE;
  }

  if (empty($column)) {
    foreach ($rows as &$row) {
      $item = array();

      if (is_array($row)) {
        foreach ($row as $key => &$value) {
          // oracle returns duplicate/redundant data in numeric rows.
          if (is_numeric($key)) continue;

          $item[$key] = $value;
        }
      }

      $items[] = $item;
    }
  }
  else {
    // return a single depth array when there is only 1 column being selected.
    foreach ($rows as &$row) {
      if (is_array($row)) {
        foreach ($row as $key => &$value) {
          // oracle returns duplicate/redundant data in numeric rows.
          if (is_numeric($key)) continue;

          $items[] = $value;
        }
      }
    }
  }

  if (empty($items)) return FALSE;

  $reset_cache_interval = new DateTime($cache_expire);
  cache_set($cache_id, $items, 'cache', $reset_cache_interval->getTimestamp());

  return $items;
}

/**
 * Returns a list of user roles available.
 *
 * @return array|bool
 *   An array containing the roles.
 *   FALSE is returned on error.
 */
function mcneese_event_workflow_load_event_user_roles() {
  $cache_id = __function__;
  $roles = &drupal_static($cache_id, NULL);
  if (is_array($roles)) {
    return $roles;
  }

  if ($cache = cache_get($cache_id)){
    return $cache->data;
  }

  $columns = array();
  $rows = (array) mcneese_event_workflow_oracle_select('select distinct role from ucs.msu_event_role');

  // strip out redundant rows provided by oracle.
  foreach ($rows as &$row) {
    if (is_array($row)) {
      foreach ($row as $key => &$value) {
        // oracle returns duplicate/redundant data in numeric rows.
        if (is_numeric($key)) continue;

        $roles[] = $value;
      }
    }
  }

  if (empty($roles)) return FALSE;

  cache_set($cache_id, $roles, 'cache', CACHE_PERMANENT);

  return $roles;
}

/**
 * Returns an array containg mapping information for oracle.
 *
 * Use this to map drupal event role taxonomy terms with the oracle roles.
 *
 * @return array|bool
 *   An array containing the mapping information.
 *   FALSE is returned on error.
 */
function mcneese_event_workflow_load_event_user_role_mapping() {
  $cache_id = __function__;
  $terms = &drupal_static($cache_id, array());
  if (!empty($terms)) {
    return $terms;
  }

  try {
    $query = db_select('taxonomy_term_data', 'ttd');
    $query->innerJoin('taxonomy_vocabulary', 'tv', 'tv.vid = ttd.vid');
    $query->fields('ttd', array('tid'));
    $query->condition('tv.machine_name', 'user_roles');

    $executed = $query->execute();
    foreach ($executed as $row) {
      $term = taxonomy_term_load($row->tid);
      $name = $term->field_role_oracle_name['und'][0]['value'];

      $terms[$name] = array('tid' => FALSE, 'role' => FALSE, 'rid' => FALSE, 'name' => FALSE);


      if (!empty($term->field_role_oracle_name['und'][0]['value'])) {
        $terms[$name]['tid'] = $row->tid;
      }

      if (!empty($term->field_role_system_name['und'][0]['value'])) {
        $role = user_role_load_by_name($term->field_role_system_name['und'][0]['value']);

        if (is_object($role)) {
          $terms[$name]['role'] = $role->name;
          $terms[$name]['rid'] = $role->rid;
        }

        unset($role);
      }

      if (!empty($term->name)) {
        $terms[$name]['name'] = $term->name;
      }
    }
  } catch (Exception $ex) {
    cf_error::on_exception($ex);

    return FALSE;
  }

  return $terms;
}

/**
 * Returns user's information.
 *
 * @param string $banner_id
 *   The numeric banner id string uniquely representing some user.
 *
 * @return array|bool
 *   An array containing the user information.
 *   FALSE is returned on error.
 */
function mcneese_event_workflow_load_event_user($banner_id) {
  $cache_id = __function__;
  $user = &drupal_static($cache_id, NULL);
  if (is_array($user)) {
    return $user;
  }

  if (!is_string($banner_id)) {
    cf_error::invalid_string('banner_id');

    return FALSE;
  }

  $user = array();
  $rows = (array) mcneese_event_workflow_oracle_select('select * from ucs.msu_event_role where id = :banner_id', array('banner_id' => $banner_id));

  // strip out redundant rows provided by oracle.
  foreach ($rows as &$row) {
    foreach ($row as $key => &$value) {
      // oracle returns duplicate/redundant data in numeric rows.
      if (is_numeric($key)) continue;

      if ($key == 'role') {
        if (!array_key_exists('role', $user)) {
          $user['role'] = array();
        }

        $user['role'][] = $value;
      }
      else {
        $user[$key] = $value;
      }
    }
  }

  if (empty($user)) return FALSE;

  return $user;
}

/**
 * Synchronizes the user settings with the oracle settings.
 *
 * @param object|null $user
 *   (optional) The user object to synchronize.
 *   If not specified, then the current user is synchronized.
 * @param array $roles
 *   (optional) Additional roles to assign the user to.
 *   Providing this will override the auto-assign role as requester.
 *   This is an array of role names and not role ids.
 *
 * @return bool
 *   TRUE on success, FALSE otherwise.
 */
function mcneese_event_workflow_synchronize_user_settings($user = NULL, $roles = array()) {
  if (is_null($user)) {
    $user = cf_current_user();
  }

  if (!is_object($user)) {
    cf_error::invalid_object('user');
    return FALSE;
  }

  if (!is_array($roles)) {
    cf_error::invalid_array('roles');
    return FALSE;
  }

  // a collection of user ids who should not have their roles changed.
  $whitelist = array();

  // skip special-case ldapless user.
  $whitelist[8] = 8;

  // kday
  $whitelist[6] = 6;

  // gfisher
  $whitelist[19] = 19;

  // colleen
  $whitelist[22] = 22;

  // gbodin
  $whitelist[23] = 23;

  // shogan
  $whitelist[45] = 45;

  if (array_key_exists($user->uid, $whitelist)) {
    return TRUE;
  }

  $mappings = mcneese_event_workflow_load_event_user_role_mapping();

  // unset all system role information associated with oracle.
  $system_roles = (array) $user->roles;
  foreach ($mappings as $mapping) {
    if (array_key_exists($mapping['rid'], $system_roles)) {
      unset($system_roles[$mapping['rid']]);
    }
  }

  // if the (non-admin) user has no core roles, then assign requester role.
  $assign_requester_role = TRUE;
  foreach ($system_roles as $key => &$role) {
    if ($role == 'administrator') {
      $assign_requester_role = FALSE;
      break;
    }

    if ($role == 'reviewer') {
      $assign_requester_role = FALSE;
      break;
    }

    if ($role == 'manager') {
      $assign_requester_role = FALSE;
      break;
    }

    if ($role == 'requester') {
      $assign_requester_role = FALSE;
      break;
    }
  }

  if (!empty($roles)) {
    $assign_requester_role = FALSE;

    foreach ($roles as $role) {
      $role = user_role_load_by_name($role);

      if (is_object($role)) {
        $system_roles[$role->rid] = $role;
      }
    }
  }

  if ($assign_requester_role) {
    $role = user_role_load_by_name('requester');
    $system_roles[$role->rid] = 'requester';
  }

  if (isset($user->field_user_banner_id['und'][0]['value'])) {
    $u = mcneese_event_workflow_load_event_user($user->field_user_banner_id['und'][0]['value']);

    if ($u == FALSE) {
      // @todo: throw watchdog error?
      $u = array();
    }

    $event_roles = array();
    if (!empty($u['role'])) {
      foreach ($u['role'] as $role) {
        if (isset($mappings[$role]['tid'])) {
          $event_roles[] = array('tid' => $mappings[$role]['tid']);
          $system_roles[$mappings[$role]['rid']] = $mappings[$role]['role'];
        }
      }
    }

    $edit = array('field_user_event_roles' => array('und' => $event_roles), 'roles' => $system_roles);

    if (user_save($user, $edit)) return TRUE;
  }

  return FALSE;
}

/**
 * Loads the user by e-mail and if the user does not exist. create it.
 *
 * @param string $email
 *   The users mcneese e-mail address.
 * @param array $roles
 *   An array of roles to assign the user to. If none is specified, then the
 *   default is to assign the reviewer role.
 *
 * @return object|false
 *   User object on success, FALSE otherwise.
 */
function mcneese_event_workflow_ensure_user_by_email($email, $roles = array()) {
  if (!is_string($email) || empty($email)) {
    cf_error::invalid_string('email');
    return FALSE;
  }

  if (!is_array($roles)) {
    cf_error::invalid_array('roles');
    return FALSE;
  }

  $email_parts = explode('@', $email);

  if (count($email_parts) != 2) {
    return FALSE;
  }

  $username = trim($email_parts[0]);
  $hostname = trim($email_parts[1]);

  if ($hostname != 'mcneese.edu' && $hostname != 'student.mcneese.edu') {
    return FALSE;
  }

  $user = user_load_by_name($username);
  if (is_object($user)) {
    return $user;
  }
  unset($user);


  // check to see if the user exists in ldap.
  $auth_conf = ldap_authentication_get_valid_conf();
  $ldap_user = FALSE;
  $ldap_server = NULL;
  $detailed_watchdog_log = variable_get('ldap_help_watchdog_detail', 0);
  $authentication_result = LDAP_AUTHENTICATION_RESULT_FAIL_GENERIC;

  foreach ($auth_conf->enabledAuthenticationServers as $sid => $ldap_server) {
    $watchdog_tokens = array();
    $authentication_result = LDAP_AUTHENTICATION_RESULT_FAIL_GENERIC;
    $result = $ldap_server->connect();

    if ($result != LDAP_SUCCESS) {
      $authentication_result = LDAP_AUTHENTICATION_RESULT_FAIL_CONNECT;
      $watchdog_tokens['%err_msg'] = $ldap_server->errorMsg('ldap');

      if ($detailed_watchdog_log) {
        watchdog('ldap_authentication',  '%username : Failed connecting to %sid.  Error: %err_msg', $watchdog_tokens, WATCHDOG_DEBUG);
      }

      continue;
    }

    $bind_success = FALSE;
    if ($ldap_server->bind_method != LDAP_SERVERS_BIND_METHOD_ANON && $ldap_server->bind_method != LDAP_SERVERS_BIND_METHOD_ANON_USER) {
      // this can only work using anonymous bindings.
      continue;
    }

    $bind_success = ($ldap_server->bind(NULL, NULL, TRUE) == LDAP_SUCCESS);

    if (!$bind_success) {
      if ($detailed_watchdog_log) {
        $watchdog_tokens['%err_text'] = $ldap_server->errorMsg('ldap');
        watchdog('ldap_authentication', '%username : Trying server %sid where bind_method = %bind_method.  Error: %err_text', $watchdog_tokens, WATCHDOG_DEBUG);
      }
      $authentication_result = ($ldap_server->bind_method == LDAP_SERVERS_BIND_METHOD_USER) ? LDAP_AUTHENTICATION_RESULT_FAIL_CREDENTIALS : LDAP_AUTHENTICATION_RESULT_FAIL_BIND;
      continue; // if bind fails, onto next server
    }

    $ldap_user = $ldap_server->userUserNameToExistingLdapEntry($username);
    if ($ldap_user !== FALSE) {
      break;
    }
  }

  if (empty($ldap_user)) {
    return FALSE;
  }


  // create the new user.
  $auth_conf = ldap_authentication_get_valid_conf();
  $watchdog_tokens = array(
    '%authname' => $username,
    '%account_name_attr' => $username,
    '%drupal_accountname' => $username,
  );

  if (!$auth_conf) {
    watchdog('ldap_authentication', 'Failed to get valid ldap authentication configuration.', array(), WATCHDOG_ERROR);
    return FALSE;
  }

  if (!$auth_conf->hasEnabledAuthenticationServers()) {
    watchdog('ldap_authentication',  'No LDAP servers configured.', array(), WATCHDOG_ERROR);
    return FALSE;
  }

  if (!$auth_conf->ldapUser->provisionEnabled(LDAP_USER_PROV_DIRECTION_TO_DRUPAL_USER, LDAP_USER_DRUPAL_USER_PROV_ON_AUTHENTICATE)) {
    watchdog('ldap_user', 'Drupal account for authname=%authname account name=%account_name_attr does not exist and provisioning of Drupal accounts on authentication is not enabled', $watchdog_tokens, WATCHDOG_INFO);
    return;
  }

  $user_register = variable_get('user_register', USER_REGISTER_VISITORS_ADMINISTRATIVE_APPROVAL);
  if ($auth_conf->ldapUser->acctCreation == LDAP_USER_ACCT_CREATION_USER_SETTINGS_FOR_LDAP && $user_register == USER_REGISTER_ADMINISTRATORS_ONLY) {
    watchdog('ldap_user', 'Failed to create account for %drupal_accountname. Administrative user must create user.', $watchdog_tokens, WATCHDOG_ERROR);
    return FALSE;
  }

  if ($auth_conf->ldapUser->acctCreation == LDAP_AUTHENTICATION_ACCT_CREATION_USER_SETTINGS_FOR_LDAP && $user_register == USER_REGISTER_VISITORS_ADMINISTRATIVE_APPROVAL) {
    $user_edit = array('name' => $username, 'mail' => $email, 'status' => 0); // if admin approval required, set status to 0.
  }
  else {
    $user_edit = array('name' => $username, 'mail' => $email, 'status' => 1);
  }

  // don't pass in ldap user to provisionDrupalAccount, because want to requery with correct attributes needed
  // this may be a case where efficiency dictates querying for all attributes
  $drupal_account = $auth_conf->ldapUser->provisionDrupalAccount(FALSE, $user_edit, NULL, TRUE);

  if ($drupal_account === FALSE) {
    watchdog('ldap_user', 'Failed to find or create %drupal_accountname.', $watchdog_tokens, WATCHDOG_ERROR);
    return FALSE;
  }

  if ($drupal_account === TRUE) {
    $drupal_account = user_load_by_name($username);
  }

  user_set_authmaps($drupal_account, array('authname_ldap_user' => $username));

  // Using Rules allows emails to be fired and many other possible reactions
  // to the creation of a user.
  if (function_exists('rules_invoke_event')) {
    rules_invoke_event('ldap_user_created', $drupal_account, FALSE);
  }

  mcneese_event_workflow_synchronize_user_settings($drupal_account, $roles);

  // reset the user object cache to force loading of new settings.
  $user = user_load($drupal_account->uid, TRUE);

  return $user;
}

/**
 * Manually trigger cache save or cache reset.
 *
 * The purpose of this is to provide a way to cache all database information.
 * The oracle database at McNeese has scheduled downtime.
 * This system is supposed to operate even when the database is down.
 * Therefore, caching is necessary and needs to be performed prior to downtime.
 *
 * @param bool $save
 *   (optional) When TRUE, caches are saved.
 *   When FALSE, caches are purged.
 */
function mcneese_event_workflow_force_cache($save = TRUE) {
  // reset is performed in both cases to ensure that the cache is fresh.
  cache_clear_all('mcneese_event_workflow_load_venue_detail_columns', 'cache');
  cache_clear_all('mcneese_event_workflow_load_venue_list_columns', 'cache');
  cache_clear_all('mcneese_event_workflow_load_event_user_roles', 'cache');

  cache_clear_all('mcneese_event_workflow_load_buildings_list', 'cache');
  cache_clear_all('mcneese_event_workflow_load_buildings_list_', 'cache', TRUE);

  cache_clear_all('mcneese_event_workflow_load_buildings', 'cache');
  cache_clear_all('mcneese_event_workflow_load_buildings_', 'cache', TRUE);

  if ($save) {
    mcneese_event_workflow_load_venue_detail_columns();
    mcneese_event_workflow_load_event_user_roles();

    $venue_list_columns = mcneese_event_workflow_load_venue_list_columns();

    if ($venue_list_columns == FALSE) {
      // @todo: throw watchdog error?
      $venue_list_columns = array();
    }

    mcneese_event_workflow_load_buildings_list();

    foreach ($venue_list_columns as $column) {
      mcneese_event_workflow_load_buildings_list($column, FALSE);
      mcneese_event_workflow_load_buildings_list($column, TRUE);
    }

    $building_locations = mcneese_event_workflow_load_buildings_list('category', TRUE);

    if ($building_locations == FALSE) {
      // @todo: throw watchdog error?
      $building_location = array();
    }

    mcneese_event_workflow_load_buildings();

    foreach ($building_locations as $location) {
      mcneese_event_workflow_load_buildings($location);
    }
  }
}

/**
 * Executes the cron queue to recreate the oracle cache.
 *
 * This requires the ultimate_cron module to function.
 *
 * @see mcneese_event_workflow_cronapi()
 * @see mcneese_event_workflow_force_cache()
 */
function mcneese_event_workflow_oracle_recache_cron() {
  mcneese_event_workflow_force_cache();
}

/**
 * Generate an array structure for a specific event request item.
 *
 * @param int $event_id
 *   The id representing the specific event request.
 * @param string $field_group
 *   The name of the group the values are associated with.
 * @param string $field_name
 *   The name of the field the values are associated with.
 * @param array $values
 *   An array of values associated with this field.
 * @param array $presentation
 *   A collection of variables to tweak how this value is presented.
 * @param array $event
 *   The event array containing all of the event values.
 *
 * @return array|bool|null
 *   The built array.
 *   NULL is returned when there should be no array to build.
 *   FALSE is returned on failure.
 */
function mcneese_event_workflow_build_event_request_item_structure($event_id, $field_group, $field_name, $values, $presentation, $event) {
  if (!cf_is_integer($event_id)) {
    cf_error::invalid_integer('event_id');
    return FALSE;
  }

  if (!is_string($field_group)) {
    cf_error::invalid_string('field_group');
    return FALSE;
  }

  if (!is_string($field_name)) {
    cf_error::invalid_string('field_name');
    return FALSE;
  }

  if (!is_array($values)) {
    cf_error::invalid_array('values');
    return FALSE;
  }

  if (!is_array($presentation)) {
    cf_error::invalid_array('presentation');
    return FALSE;
  }

  $event = event_workflow_load_event_by_id($event_id);
  if (empty($event)) {
    return FALSE;
  }

  // define if the label should be displayed or not.
  $label_display = TRUE;
  if (!empty($presentation['label_display'])) {
    $label_display = (bool) $presentation['label_display'];
  }

  // define when label gets placed (prepend or postpend).
  $label_prepend = TRUE;
  if (!empty($presentation['label_prepend'])) {
    $label_prepend = (bool) $presentation['label_prepend'];
  }

  // define when label gets placed (prepend or postpend).
  $size = 'auto';
  if (!empty($presentation['size'])) {
    $size = (string) $presentation['size'];
  }

  // define the label text presented to the user.
  $label = '';
  if (isset($presentation['label'])) {
    $label = $presentation['label'];
  }

  $label_length = strlen($label);

  // define the collate to alter how the fields are displayed.
  $collate = FALSE;
  $collate_name = '';
  if (!empty($presentation['collate'])) {
    $collate = TRUE;
    $collate_name = $presentation['collate'];
  }

  $output = array();
  $no_values = TRUE;
  foreach ($values as $delta => &$value) {
    $generated = mcneese_event_workflow_build_event_request_value_structure($event_id, $field_group, $field_name, $delta, $value, $presentation, $event);

    if ($generated !== FALSE && !isset($generated['no_values'])) {
      $id = 'field-event-' . $event_id . '-item-' . $field_group . '-' . $field_name . '-' . $delta;

      if ($size == 'auto') {
        $size = 'small';

        $value_length = 0;
        if (!empty($generated)) {
          foreach ($generated as $key => $generated_value) {
            if (isset($generated_value['markup']['#length'])) {
              $value_length += $generated_value['markup']['#length'];
            }
          }
        }

        if ($label_length + $value_length > 50) {
          $size = 'large';
        }
      }

      $output[$delta] = array(
        '#id' => $id,
        '#type' => 'container',
        '#attributes' => array(
          'class' => array(
            'item-delta-' . $delta,
            'item-request-' . $event_id,
            'item-group-' . $field_group,
            'item-field-' . $field_name,
            'item-size-' . $size,
            'item-event',
          ),
        ),
      );

      if ($label_display) {
        $output[$delta]['label'] = array(
          '#type' => 'container',
          '#attributes' => array(
            'class' => array(
              'item-label',
            ),
          ),
          '#weight' => ($label_prepend) ? -1 : 1,
        );

        $output[$delta]['label']['markup'] = array(
          '#markup' => $label,
        );
      }

      $output[$delta]['value'] = $generated;
      $no_values = FALSE;
    }

    unset($generated);
  }

  if ($no_values) {
    // this is added in case later on it is decided that $output should be returned.
    // the item class needs to communicate that this group has no values.
    $delta = 0;

    $class = $field_group . '-' . $field_name . '-' . $delta;
    $id = 'field-event-' . $event_id . '-item-' . $class;

    $output = array();
    $output[$delta] = array(
      '#id' => $id,
      '#type' => 'container',
      '#attributes' => array(
        'class' => array(
          'field-event-item',
          'field-event-item-' . $class,
          'field-event-item-size-' . $size,
        ),
      ),
    );

    $output['item']['#attributes']['class'][] = 'field-event-item-no_values';

    return NULL;
  }

  return $output;
}

/**
 * Generate an array structure for a specific event request value.
 *
 * @param int $event_id
 *   The id representing the specific event request.
 * @param string $field_group
 *   The name of the group the values are associated with.
 * @param string $field_name
 *   The name of the field the values are associated with.
 * @param int $delta
 *   This is for multiple values, each value has its own delta.
 * @param object $value
 *   The value object in the format in the database structure or in a sumulated
 *   structure.
 * @param array $presentation
 *   A collection of variables to tweak how this value is presented.
 * @param array $event
 *   The event array containing all of the event values.
 *
 * @return array|bool
 *   The built array.
 *   FALSE is returend on failure.
 */
function mcneese_event_workflow_build_event_request_value_structure($event_id, $field_group, $field_name, $delta, $value, $presentation, $event) {
  if (!is_string($field_group)) {
    cf_error::invalid_string('field_group');
    return FALSE;
  }

  if (!is_string($field_name)) {
    cf_error::invalid_string('field_name');
    return FALSE;
  }

  if (!cf_is_integer($delta)) {
    cf_error::invalid_integer('delta');
    return FALSE;
  }

  if (!is_object($value)) {
    cf_error::invalid_object('value');
    return FALSE;
  }

  if (!is_array($presentation)) {
    cf_error::invalid_array('presentation');
    return FALSE;
  }

  $event = event_workflow_load_event_by_id($event_id);
  if (empty($event)) {
    return FALSE;
  }

  // define the combined option.
  $combined = FALSE;
  if (!empty($presentation['combined'])) {
    $combined = (bool) $presentation['combined'];
  }

  // define the presentation type.
  $type = array('value' => 'string');
  if (!empty($presentation['type'])) {
    $type = (array) $presentation['type'];
  }

  // define the presentation display.
  $display = array('value' => 'raw');
  if (!empty($presentation['display'])) {
    $display = (array) $presentation['display'];
  }

  // define the presentation value names.
  $value_names = array('value');
  if (!empty($presentation['value_names'])) {
    $value_names = (array) $presentation['value_names'];
  }

  // define a prefix to append before the value.
  $prefix = '';
  if (!empty($presentation['prefix'])) {
    $prefix = $presentation['prefix'];
  }

  // define a suffix to prepend after the value.
  $suffix = '';
  if (!empty($presentation['suffix'])) {
    $suffix = $presentation['suffix'];
  }

  $venue_coordinator = NULL;
  if (!empty($event['venue_coordinator']['user_id'][0]->value)) {
    $venue_coordinator = user_load($event['venue_coordinator']['user_id'][0]->value);
  }

  global $base_path;

  $id = 'field-event-' . $event_id . '-item-' . $field_group . '-' . $field_name . '-' . $delta . '-value';

  $output = array();
  $empty_value = TRUE;
  $no_values = TRUE;

  foreach ($value_names as $value_name) {
    if ($combined) {
      if (!isset($output['value']['markup']['#markup'])) {
        $output['value'] = array(
          '#id' => $id . '-' . $value_name,
          '#type' => 'container',
          '#attributes' => array(
            'class' => array(
              'item-value',
              'item-value-name-' . $value_name,
            ),
          ),
        );

        $output['value']['markup'] = array(
          '#markup' => NULL,
        );

        if (!array_key_exists('value', $type)) {
          $type['value'] = 'string';
        }

        $output['value']['#attributes']['class'][] = 'item-value-type-value';

        $output['value']['markup']['#length'] = 0;
      }

      $markup = &$output['value']['markup']['#markup'];
      $output_value = &$output['value'];
      $length = &$output['value']['markup']['#length'];
    }
    else {
      $output[$value_name] = array(
        '#id' => $id . '-' . $value_name,
        '#type' => 'container',
        '#attributes' => array(
          'class' => array(
            'item-value',
            'item-value-name-' . $value_name,
          ),
        ),
      );

      $output[$value_name]['markup'] = array(
        '#markup' => NULL,
      );

      if (!array_key_exists($value_name, $type)) {
        $type[$value_name] = 'string';
      }

      $output[$value_name]['#attributes']['class'][] = 'item-value-type-' . $type[$value_name];
      $output['value']['markup']['#length'] = 0;

      $markup = &$output[$value_name]['markup']['#markup'];
      $output_value = &$output[$value_name];
      $length = &$output['value']['markup']['#length'];
    }

    if (property_exists($value, $value_name) && (is_numeric($value->$value_name) || !empty($value->$value_name))) {
      if ($type[$value_name] == 'string' || $type[$value_name] == 'text') {
        $markup .= check_plain($value->$value_name);

        $length += strlen($value->$value_name);
      }
      elseif ($type[$value_name] == 'timestamp') {
        if (!array_key_exists($value_name, $display)) {
          $display[$value_name] = 'Y/m/d h:ia';
        }

        if ($display[$value_name] == 'stamp') {
          $markup .= check_plain($value->$value_name);
        }
        else {
          $markup .= check_plain(date($display[$value_name], $value->$value_name));
        }

        $length += strlen($value->$value_name);
      }
      elseif ($type[$value_name] == 'taxonomy') {
        $term = taxonomy_term_load($value->$value_name);

        if (is_object($term)) {
          $markup .= check_plain($term->name);
          $length += strlen($term->name);
        }

        unset($term);
      }
      elseif ($type[$value_name] == 'user_id') {
        $user = user_load($value->$value_name);

        if (is_object($user)){
          if (!array_key_exists($value_name, $display)) {
            $display[$value_name] = 'name';
          }

          $user_name = check_plain($user->name);

          if (!empty($user->field_user_last_name['und'][0]['value'])) {
            $user_name = check_plain($user->field_user_last_name['und'][0]['value']) . ', ';
          }

          if (!empty($user->field_user_first_name['und'][0]['value'])) {
            $user_name .= check_plain($user->field_user_first_name['und'][0]['value']);
          }

          if ($display[$value_name] == 'account_name') {
            $markup .= '<a href="' . $base_path . 'user/' . $user->uid . '">' . $user_name . '</a>';
            $length += strlen($user_name);
          }
          elseif ($display[$value_name] != 'pass' && property_exists($user, $display)) {
            $markup .= check_plain($user->$display[$value_name]);
            $length += strlen($user->$display[$value_name]);
          }
        }

        unset($user);
      }
      elseif ($type[$value_name] == 'status') {
        mcneese_event_workflow_include(4);

        $status_options = event_workflow_get_event_status_list_options();

        if (isset($status_options[$value->$value_name])) {
          $markup .= $status_options[$value->$value_name];
          $length += strlen($value->$value_name);
        }
      }
      elseif ($type[$value_name] == 'step') {
        mcneese_event_workflow_include(4);

        $step_options = event_workflow_get_event_steps_list_options();

        if (isset($step_options[$value->$value_name])) {
          $markup .= $step_options[$value->$value_name];
          $length += strlen($step_options[$value->$value_name]);
        }
      }
      elseif ($type[$value_name] == 'location') {
        mcneese_event_workflow_include(4);

        $location_options = event_workflow_get_event_location_list_options();

        if (isset($location_options[$value->$value_name])) {
          $markup .= $location_options[$value->$value_name];
          $length += strlen($location_options[$value->$value_name]);
        }
      }
      elseif ($type[$value_name] == 'building') {
        mcneese_event_workflow_include(4);

        $building_options = event_workflow_get_event_building_list_options();

        if (isset($building_options[$value->$value_name])) {
          $markup .= $building_options[$value->$value_name];
          $length += strlen($building_options[$value->$value_name]);
        }
      }
      elseif ($type[$value_name] == 'room') {
        mcneese_event_workflow_include(4);

        $room_options = event_workflow_get_event_room_list_options();

        if (isset($room_options[$value->$value_name])) {
          $markup .= $room_options[$value->$value_name];
          $length += strlen($room_options[$value->$value_name]);
        }
      }
      elseif ($type[$value_name] == 'currency') {
        $currency = event_workflow_convert_value_from_database_format($value->$value_name, 'currency');

        if ($currency !== FALSE) {
          $processed_markup = '$' . printf('%01.2f', $currency);
          $markup .= $processed_markup;
          $length += strlen($processed_markup);
        }
      }
      elseif ($type[$value_name] == 'boolean') {
        $boolean = (bool) $value->$value_name;

        if ($boolean) {
          $markup .= 'yes';
          $length += 3;
        }
        else {
          $markup .= 'no';
          $length += 2;
        }

        if ($display[$value_name] == 'when_true') {
          if (!$boolean) {
            continue;
          }
        }
        elseif ($display[$value_name] == 'when_false') {
          if ($boolean) {
            continue;
          }
        }
      }
      elseif ($type[$value_name] == 'use_fee_personnel') {
        $markup .= ' ' . $value->$value_name . ' personnel';
        $length += strlen($value->$value_name . ' personnel');
      }
      elseif ($type[$value_name] == 'use_fee_hours') {
        $markup .= ' ' . $value->$value_name . ' hours';
        $length += strlen($value->$value_name . ' hours');
      }
      elseif ($type[$value_name] == 'use_fee_days') {
        $markup .= ' ' . $value->$value_name . ' days';
        $length += strlen($value->$value_name . 'days');
      }
      elseif ($type[$value_name] == 'use_fee_amount') {
        $amount = event_workflow_convert_value_from_database_format($value->$value_name, 'currency');

        if ($amount !== FALSE) {
          $processed_markup = ' at $' . sprintf('%01.2f', $amount);

          // calculate total and append from other fields that should exist.
          $total = $amount;

          if (in_array('quantity', $value_names) && isset($value->quantity) && is_numeric($value->quantity)) {
            $total = $total * $value->quantity;
          }

          if (in_array('hours', $value_names) && isset($value->hours) && is_numeric($value->hours)) {
            $total = $total * $value->hours;
          }

          if (in_array('days', $value_names) && isset($value->days) && is_numeric($value->days)) {
            $total = $total * $value->days;
          }

          $processed_markup .= ' = $' . sprintf('%01.2f', $total);

          $markup .= $processed_markup;
          $length += strlen($processed_markup);
        }
      }
      elseif ($type[$value_name] == 'venue_coordinator') {
        if ($display[$value_name] == 'name') {
          $processed_markup = '';

          $first_name = FALSE;
          if (!empty($venue_coordinator->field_user_last_name['und'][0]['safe_value'])) {
            $first_name = TRUE;
            $processed_markup .= $venue_coordinator->field_user_last_name['und'][0]['safe_value'];
          }

          if (!empty($venue_coordinator->field_user_first_name['und'][0]['safe_value'])) {
            if ($first_name) {
              $processed_markup .=  ', ';
            }

            $processed_markup .= $venue_coordinator->field_user_first_name['und'][0]['safe_value'];
          }

          $markup .= $processed_markup;
          $length += strlen($processed_markup);
        }
        elseif ($display[$value_name] == 'email') {
          $markup .= $venue_coordinator->mail;
          $length += strlen($venue_coordinator->mail);
        }
        elseif ($display[$value_name] == 'phone') {
          if (!empty($venue_coordinator->field_user_phone_number['und'][0]['safe_value'])) {
            $markup .= $venue_coordinator->field_user_phone_number['und'][0]['safe_value'];
            $length += strlen($venue_coordinator->field_user_phone_number['und'][0]['safe_value']);
          }
        }
      }
      elseif ($type[$value_name] == 'review_decision') {
        if ($value->$value_name == MEW_REVIEW_DECISION_APPROVE) {
          $markup .= "Approved";
          $length += strlen("Approved");
        }
        elseif ($value->$value_name == MEW_REVIEW_DECISION_DENY) {
          $markup .= "Denied";
          $length += strlen("Denied");
        }
      }

      if (!is_numeric($markup) && empty($markup)) {
        $output_value['#attributes']['class'][] = 'empty_value';
      }
      else {
        $empty_value = FALSE;

        if (!$combined) {
          $markup = $prefix . $markup . $suffix;
        }
      }

      $no_values = FALSE;
    }
  }

  if ($no_values) {
    $output_value['#attributes']['class'][] = 'no_value';
    $output['no_values'] = TRUE;
  }
  elseif ($combined && !$empty_value) {
    $output['value']['markup']['#markup'] = $prefix . $output['value']['markup']['#markup'] . $suffix;
  }

  return $output;
}

/***
 * Convert a given value to the appropraite database format.
 *
 * @param string $value
 *   The date or time string to convert.
 * @param string $method
 *   The method to use for converting.
 * @param string|array $option
 *   (optional) Additional options to pass to the method for conversion.
 * @param array $form_state
 *   (optional) The form state array, containing all available values.
 * @param array $delta
 *   (optional) The delta location for processing data of the same delta.
 *
 * @return
 *   The appropriate datatype suitable for storing into the database.
 *   FALSE is returned on error.
 */
function event_workflow_convert_value_to_database_format($value, $method, $option = array(), $form_state = array(), $delta = array()) {
  if ($method == 'timestamp') {
    if (empty($value)) {
      return FALSE;
    }

    if (array_key_exists('relative_to', $option) && is_string($option['relative_to']) && !empty($option['relative_to'])) {
      if (!is_array($form_state) || !array_key_exists('values', $form_state)) {
        return FALSE;
      }

      $current = &$form_state['values'];

      $parts = explode('][', $option['relative_to']);
      foreach ($parts as $part) {
        if (is_array($current) && array_key_exists($part, $current)) {
          $current = &$current[$part];
        }
        else {
          return FALSE;
        }
      }

      if (is_array($current) && array_key_exists($delta, $current)) {
        $current = &$current[$delta];
      }
      else {
        return FALSE;
      }

      $date_stamp = strtotime($current, 0);
      return strtotime($value, $date_stamp);
    }

    return strtotime($value);
  }
  elseif ($method == 'date_popup') {
    if (!is_string($value) || empty($value)) {
      return FALSE;
    }

    // force the date to begin at the earlies time in the day.
    $date_stamp = strtotime($value);
    $date = date("Y/m/d", $date_stamp);
    return strtotime($date, 0);
  }
  elseif ($method == 'currency') {
    if (is_null($value)) {
      return FALSE;
    }

    // shift decimal over to digits.
    return floor($value * 100);
  }

  return FALSE;
}

/***
 * Convert a given value to the appropraite database format.
 *
 * @param string $value
 *   The date or time string to convert.
* @param string $method
 *   The method to use for converting.
 * @param string|array $option
 *   (optional) Additional options to pass to the method for conversion.
 *
 * @return
 *   The appropriate datatype suitable for storing into the database.
 *   FALSE is returned on error.
 */
function event_workflow_convert_value_from_database_format($value, $method, $option = array()) {
  if ($method == 'timestamp') {
    if (empty($value)) return NULL;

    return date($option['view'], $value);
  }
  elseif ($method == 'date_popup') {
    if (empty($value)) return NULL;

    return date('Y-m-d', $value);
  }
  elseif ($method == 'currency') {
    if (is_null($value)) return NULL;

    return $value / 100;
  }

  return FALSE;
}

/**
 * Loads an event by its ID.
 *
 * @param int $event_id
 *   The numeric event id.
 * @param bool $reset
 *   (optional) If TRUE, the cache for the specified event is reset.
 *
 * @return array|bool
 *   An array of values associated with the event id.
 *   FALSE is returned on error.
 *   An empty array is returned when there is no event by that id.
 */
function event_workflow_load_event_by_id($event_id, $reset = FALSE) {
  if (!cf_is_integer($event_id)) {
    cf_error::invalid_integer('event_id');
    return FALSE;
  }

  $cache_id = __function__;
  $cached_events = &drupal_static($cache_id, NULL);
  if (!$reset && is_array($cached_events) && array_key_exists($event_id, $cached_events)) {
    return $cached_events[$event_id];
  }

  mcneese_event_workflow_include(0);

  $event = array();
  $structure = mcneese_event_workflow_table_structure();

  try {
    $query = db_select('mew_event_requests', 'mer');
    $query->fields('mer');
    $query->condition('id', $event_id);

    $results = $query->execute()->fetchAll();

    if (empty($results)) {
      return array();
    }

    $mer = array_pop($results);

    // manually add the event request information and presentation fields.
    if (!isset($event['mer'])) {
      $event['mer'] = array();
      foreach (array('id', 'user_id', 'created', 'updated') as $key) {
        $event['mer'][$key] = array(0 => new stdClass());
        $event['mer'][$key][0]->value = $mer->$key;
      }
    }

    foreach ($structure as $table_name => &$fields) {
      $current_table_name = 'mew_current_' . $table_name;

      if (!array_key_exists($table_name, $event)) {
        $event[$table_name] = array();
      }

      $query = db_select($current_table_name, 'mctn');
      $query->condition('mctn.event_id', $event_id);
      $query->fields('mctn');

      $results = $query->execute()->fetchAll();

      if (empty($results)) {
        unset($current);
        unset($executed);
        unset($query);

        continue;
      }

      $current = array_pop($results);

      // build a list of current tables so that revision ids may be processed at any point.
      if (!isset($event['current'])) {
        $event['current'] = array();
      }

      $event['current'][$table_name] = array();
      foreach ((array) $current as $current_keys => $current_values) {
        if ($current_keys == 'event_id') continue;
        $event['current'][$table_name][$current_keys] = $current_values;
      }

      foreach ($fields as $field_name => &$field_values) {
        if (isset($structure[$table_name][$field_name]['storage']) && $structure[$table_name][$field_name]['storage'] == 'alternate' && array_key_exists('alternate', $structure[$table_name][$field_name])) {
          foreach ($structure[$table_name][$field_name]['alternate'] as $alternate_name => &$alternate_data) {
            $field_table_name = 'mew_field_' . $table_name . '_' . $alternate_name;

            $query = db_select($field_table_name, 'mftf');
            $query->condition('mftf.event_id', $event_id);
            $query->condition('mftf.revision', $current->$alternate_name);
            $query->fields('mftf');

            $results = $query->execute()->fetchAll();

            if (empty($results)) {
              $event[$table_name][$alternate_name] = array();
            }
            else {
              $event[$table_name][$alternate_name] = $results;
            }
          }
        }
        else {
          $field_table_name = 'mew_field_' . $table_name . '_' . $field_name;

          $query = db_select($field_table_name, 'mftf');
          $query->condition('mftf.event_id', $event_id);
          $query->condition('mftf.revision', $current->$field_name);
          $query->fields('mftf');

          $results = $query->execute()->fetchAll();

          if (empty($results)) {
            $event[$table_name][$field_name] = array();
          }
          else {
            $event[$table_name][$field_name] = $results;
          }
        }

        unset($results);
        unset($query);
      }

      unset($current);
      unset($results);
      unset($query);
    }
  }
  catch (Exception $ex) {
    cf_error::on_exception($ex);
    return FALSE;
  }

  $cached_events[$event_id] = &$event;

  return $cached_events[$event_id];
}


/**
 * Loads event with fields matching a revision timestamp.
 *
 * @param int $event_id
 *   The numeric event id.
 * @param int $revision
 *   Unix Timestamp representing the exact date and time to load.
 * @param array $desired_fields
 *   (optional) An array of field names to load that match the specified date.
 *   These are nested by their table structure. When an empty array is
 *   provided, all values are used.
 * @param bool $reset
 *   (optional) If TRUE, the cache for the specified event is reset.
 *
 * @return array|bool
 *   An array of values associated with the event, date, and fields.
 *   FALSE is returned on error.
 *
 * @see mcneese_event_workflow_table_structure()
 */
function event_workflow_load_event_by_timestamp($event_id, $revision, $desired_fields = array()) {
  if (!cf_is_integer($event_id)) {
    cf_error::invalid_integer('event_id');
    return FALSE;
  }

  if (!cf_is_integer($revision)) {
    cf_error::invalid_integer('revision');
    return FALSE;
  }

  if (!is_array($desired_fields)) {
    cf_error::invalid_array('desired_fields');
    return FALSE;
  }

  mcneese_event_workflow_include(0);

  $event = array();
  $structure = mcneese_event_workflow_table_structure();

  // filter out all fields that were not requested.
  if (!empty($desired_fields)) {
    foreach ($structure as $table_name => &$fields) {
      if (!array_key_exists($table_name, $desired_fields)) {
        unset($structure[$table_name]);
        continue;
      }

      foreach ($fields as $field_name => &$field_values) {
        if (!array_key_exists($field_name, $desired_fields)) {
          unset($structure[$field_name]);
          continue;
        }
      }
    }
  }

  try {
    $query = db_select('mew_event_requests', 'mer');
    $query->innerjoin('mew_event_revisions', 'merv', 'mer.id = merv.event_id');

    $query->fields('mer');
    $query->addField('merv', 'revision', 'revision');

    $query->condition('id', $event_id);
    $query->condition('merv.date', $revision);

    $query->orderby('merv.date');

    $results = $query->execute()->fetchAll();

    // manually add the event request information and presentation fields.
    $event['mer'] = array();
    if (!empty($results)) {
      foreach ($results as $index => $mer) {
        foreach (array('id', 'user_id', 'created', 'updated') as $key) {
          if (!isset($event['mer'][$key][$mer->revision])) {
            $event['mer'][$key][$mer->revision] = new stdClass();
          }

          $event['mer'][$key][$mer->revision]->value = $mer->$key;
        }
      }
    }

    foreach ($structure as $table_name => &$fields) {
      $current_table_name = 'mew_current_' . $table_name;

      if (!array_key_exists($table_name, $event)) {
        $event[$table_name] = array();
      }

      // build a list of current tables so that revision ids may be processed at any point.
      if (!isset($event['current'])) {
        $event['current'] = array();
      }

      $event['current'][$table_name] = array();

      foreach ($fields as $field_name => &$field_values) {
        if (isset($structure[$table_name][$field_name]['storage']) && $structure[$table_name][$field_name]['storage'] == 'alternate' && array_key_exists('alternate', $structure[$table_name][$field_name])) {
          foreach ($structure[$table_name][$field_name]['alternate'] as $alternate_name => &$alternate_data) {
            $field_table_name = 'mew_field_' . $table_name . '_' . $alternate_name;

            $query = db_select($field_table_name, 'mftf');
            $query->condition('mftf.event_id', $event_id);
            $query->condition('mftf.date', $revision);
            $query->fields('mftf');

            $results = $query->execute()->fetchAll();

            if (empty($results)) {
              $event[$table_name][$alternate_name] = array();

              $event['current'][$table_name][$field_name] = NULL;
            }
            else {
              $event[$table_name][$alternate_name] = $results;

              $first_result = reset($results);
              $event['current'][$table_name][$field_name] = $first_result->revision;
            }
          }
        }
        else {
          $field_table_name = 'mew_field_' . $table_name . '_' . $field_name;

          $query = db_select($field_table_name, 'mftf');
          $query->condition('mftf.event_id', $event_id);
          $query->condition('mftf.date', $revision);
          $query->fields('mftf');

          #$results = $query->execute()->fetchAll();
          $executed = $query->execute();
          $results = $executed->fetchAll();

          if (empty($results)) {
            $event[$table_name][$field_name] = array();

            $event['current'][$table_name][$field_name] = NULL;
          }
          else {
            $event[$table_name][$field_name] = $results;

            $first_result = reset($results);
            $event['current'][$table_name][$field_name] = $first_result->revision;
          }
        }

        unset($results);
        unset($query);
      }

      unset($results);
      unset($query);
    }
  }
  catch (Exception $ex) {
    cf_error::on_exception($ex);
    return FALSE;
  }

  return $event;
}

/**
 * Loads the event revision number.
 *
 * @param int $event_id
 *   The numeric event id.
 * @param string $table_field_name
 *   (optional) The name of a specific table to load a revision number from.
 *   When not specified, this returns the latest revision number of a given
 *   event.
 *
 * @return int|bool
 *  FALSE is returned on error.
 *  NULL is returned when there is no existing revision number.
 */
function mcneese_event_workflow_load_event_revision_number($event_id, $table_field_name = NULL) {
  if (!cf_is_integer($event_id)) {
    cf_error::invalid_integer('event_id');
    return FALSE;
  }

  if (is_null($table_field_name)) {
    try {
      $query = db_select('mew_event_revisions', 'merv');
      $query->addfield('merv', 'revision', 'revision');
      $query->condition('merv.event_id', $event_id);
      $query->orderby('merv.revision', 'DESC');
      $query->range(0, 1);

      $field = $query->execute()->fetchfield();

      if ($field === FALSE) {
        return NULL;
      }

      return $field;
    }
    catch (Exception $ex) {
      cf_error::on_query_execution($ex);
    }

    return FALSE;
  }

  if (!is_string($table_field_name)) {
    cf_error::invalid_string('table_field_name');
    return FALSE;
  }

  try {
    $query = db_select($table_field_name, 'tfn');
    $query->fields('tfn', array('revision'));
    $query->condition('tfn.event_id', $event_id);
    $query->orderBy('tfn.revision', 'DESC');
    $query->range(0, 1);

    $result = $query->execute()->fetchField();

    return $result;
  }
  catch (Exception $ex) {
    cf_error::on_exception($ex);
    return FALSE;
  }

  return FALSE;
}

/**
 * Loads a system user by its Banner ID.
 *
 * @param int $banner_id
 *   The numeric banner id.
 * @param bool $reset
 *   (optional) If TRUE, the cache for the specified user is reset.
 *
 * @return object|null|bool
 *   The
 *   FALSE is returned on error.
 *   An empty array is returned when there is no event by that id.
 */
function event_workflow_load_user_by_banner_id($banner_id, $reset = FALSE) {
  if (!cf_is_integer($banner_id)) {
    cf_error::invalid_integer('banner_id');
    return FALSE;
  }

  $cache_id = __function__;
  $cached_user = &drupal_static($cache_id, NULL);
  if (!$reset && is_array($cached_user) && array_key_exists($banner_id, $cached_user)) {
    return $cached_user[$banner_id];
  }

  try {
    $query = db_select('users', 'u');

    $query->innerjoin('field_data_field_user_first_name', 'fdfufn', 'u.uid = fdfufn.entity_id AND fdfufn.delta = 0');
    $query->innerjoin('field_data_field_user_last_name', 'fdfuln', 'u.uid = fdfuln.entity_id AND fdfuln.delta = 0');
    $query->innerjoin('field_data_field_user_banner_id', 'fdfubi', 'u.uid = fdfubi.entity_id AND fdfubi.delta = 0');

    $query->addField('u', 'uid', 'user_id');
    $query->addField('u', 'name', 'name');
    $query->addField('u', 'created', 'created');
    $query->addField('u', 'status', 'status');
    $query->addField('u', 'mail', 'email');

    $query->addField('fdfufn', 'field_user_first_name_value', 'first_name');
    $query->addField('fdfuln', 'field_user_last_name_value', 'last_name');
    $query->addField('fdfubi', 'field_user_banner_id_value', 'banner_id');

    $query->condition('field_user_banner_id_value', $banner_id);

    $results = $query->execute()->fetchAll();
  }
  catch (Exception $ex) {
    cf_error::on_exception($ex);
    return FALSE;
  }

  if (empty($results)) {
    return NULL;
  }

  $cached_user[$banner_id] = array_pop($results);

  return $cached_user[$banner_id];
}

/**
 * Build the table structure for saving new or existing information.
 *
 * @param array $structure
 *   Describes how the secondary tables are populated and processed.
 * @param array $structure_tables
 *   A collection of 'current' tables to create or update.
 * @param array $structure_field_tables
 *   A collection of 'field' tables to create or update.
 * @param string $table_name
 *   Name of the current table being processed.
 * @param string $field_name
 *   Name of the current field being processed.
 * @param string $db_table
 *   The name of the 'current' table as defined the SQL database.
 * @param string $db_table_field
 *   The name of the 'field' table as defined the SQL database.
 * @param array $user_data
 *   An array of user related information:
 *   - 'user_id': The users ID.
 * @param array $form_state
 *   The form state for advanced processing of fields that depend on other
 *   fields when they are converted into the database format.
 * @param array|null $event
 *   (optional) When NULL, this created tables are new tables.
 *   When an array, the created tables are updates to existing values.
 *   The array should be populated by event_workflow_load_event_by_id().
 *
 * @see mcneese_event_workflow_table_structure()
 * @see event_workflow_load_event_by_id()
 */
function mcneese_event_workflow_build_table_structure($structure, &$structure_tables, &$structure_field_tables, $table_name, $field_name, $db_table, $db_table_field, $user_data, $values, $form_state, $event = NULL) {
  if (is_null($event)) {
    $event_id = NULL;
    $revision = 0;
  }
  else {
    $event_id = $event['mer']['id'][0]->value;
    $structure_tables[$db_table]['event_id'] = $event_id;

    $revision = mcneese_event_workflow_load_event_revision_number($event_id, $db_table_field);
    if ($revision === FALSE) {
      watchdog('mew', "Failed to load revision number for event %event_id while building the table structure, forcing revision number to be 0.", array('%event_id' => $event_id), WATCHDOG_ERROR);
      $revision = 0;
    }
    elseif (is_null($revision)) {
      $revision = 0;
    }
    else {
      $revision++;
    }
  }

  if (!isset($structure_field_tables[$db_table_field])) {
    $structure_field_tables[$db_table_field] = array();
  }

  if (array_key_exists('storage', $structure[$table_name][$field_name])) {
    if (!is_string($structure[$table_name][$field_name]['storage']) || empty($structure[$table_name][$field_name]['storage'])) {
      // @todo: present a watchdog error message here.
      return;
    }

    $storage_key = $structure[$table_name][$field_name]['storage'];
    if (!array_key_exists($storage_key, $structure[$table_name][$field_name]) || empty($structure[$table_name][$field_name][$storage_key])) {
      // @todo: present a watchdog error message here.
      return;
    }

    // alternate is used for handling fields that are stored in multiple separate tables.
    if ($storage_key == 'alternate') {
      unset($structure_tables[$db_table][$field_name]);
      unset($structure_field_tables[$db_table_field]);

      foreach ($values as $delta => $value) {
        $alternate_values = array();
        if (!empty($structure[$table_name][$field_name]['alternate_method'])) {
          foreach ($structure[$table_name][$field_name]['alternate_method'] as $method_name => $method_values) {
            if ($method_name == 'explode') {
              $alternate_values = explode($method_values[0], $value, $method_values[1]);
            }
            break;
          }
        }

        foreach ($structure[$table_name][$field_name]['alternate'] as $alternate_name => &$alternate_data) {
          if (!array_key_exists('key', $alternate_data)) continue;

          $db_table_field = 'mew_field_' . $table_name . '_' . $alternate_name;

          if (!isset($structure_field_tables[$db_table_field])) {
            $structure_field_tables[$db_table_field] = array();
          }

          $structure_field_tables[$db_table_field][$delta] = array();
          $structure_field_tables[$db_table_field][$delta]['user_id'] = $user_data['user_id'];
          $structure_field_tables[$db_table_field][$delta]['date'] = REQUEST_TIME;
          $structure_field_tables[$db_table_field][$delta]['delta'] = $delta;
          $structure_field_tables[$db_table_field][$delta]['revision'] = $revision;

          if (isset($alternate_values[$alternate_data['key']]) && (is_numeric($alternate_values[$alternate_data['key']]) || !empty($alternate_values[$alternate_data['key']]))) {
            $structure_field_tables[$db_table_field][$delta]['value'] = $alternate_values[$alternate_data['key']];
          }

          if (!is_null($event_id)) {
            $structure_field_tables[$db_table_field][$delta]['event_id'] = $event_id;
          }

          $structure_tables[$db_table][$alternate_name] = $revision;
        }
      }
    }
    else {
      $structure_tables[$db_table][$field_name] = $revision;

      foreach ($values as $delta => $value) {
        $structure_field_tables[$db_table_field][$delta] = array();
        $structure_field_tables[$db_table_field][$delta]['user_id'] = $user_data['user_id'];
        $structure_field_tables[$db_table_field][$delta]['date'] = REQUEST_TIME;
        $structure_field_tables[$db_table_field][$delta]['delta'] = $delta;
        $structure_field_tables[$db_table_field][$delta]['revision'] = $revision;

        if (!is_null($event)) {
          $structure_field_tables[$db_table_field][$delta]['event_id'] = $event_id;
        }

        $storage_values = FALSE;
        if (isset($structure[$table_name][$field_name][$storage_key]) && is_array($structure[$table_name][$field_name][$storage_key])) {
          $storage_values = event_workflow_convert_value_to_database_format($value, $storage_key, $structure[$table_name][$field_name][$storage_key], $form_state, $delta);
        }

        if ($storage_values !== FALSE && !is_null($storage_values)) {
          $structure_field_tables[$db_table_field][$delta]['value'] = $storage_values;
        }
      }
    }
  }
  else {
    $structure_tables[$db_table][$field_name] = $revision;

    foreach ($values as $delta => $value) {
      $structure_field_tables[$db_table_field][$delta] = array();
      $structure_field_tables[$db_table_field][$delta]['user_id'] = $user_data['user_id'];
      $structure_field_tables[$db_table_field][$delta]['date'] = REQUEST_TIME;
      $structure_field_tables[$db_table_field][$delta]['delta'] = $delta;
      $structure_field_tables[$db_table_field][$delta]['revision'] = $revision;

      if (!is_null($event)) {
        $structure_field_tables[$db_table_field][$delta]['event_id'] = $event_id;
      }

      if (isset($structure[$table_name][$field_name]['columns'])) {
        foreach ($structure[$table_name][$field_name]['columns'] as $special_field_id => &$special_field_name) {
          if (isset($value[$special_field_id]) && $value[$special_field_id] > 0) {
            $structure_field_tables[$db_table_field][$delta][$special_field_name] = $special_field_id;
          }
        }
      }
      elseif (is_numeric($value) || !empty($value)) {
        $structure_field_tables[$db_table_field][$delta]['value'] = $value;
      }
    }
  }
}

/**
 * Returns the reviewers.
 *
 * @param array $conditions
 *   An array containing select conditions, such as:
 *   - 'mr.id': reviewer id.
 *   - 'mr.user_id': user id (uid).
 *   - 'mr.event_classification': event classification.
 *   - 'mr.review_step': event review step.
 *   - 'mr.reviewer_classification': reviewer classification.
 * @param bool $join
 *   (optional) When TRUE, the drupal user table is joined to the reviewers table.
 *   Only select portions of the user table is joined.
 *   This also joins custom field tables for user first and last name.
 * @param array $sort
 *   (optional) When specified, representings the database sorting.
 *
 * @return array|false
 *   An array of database objects representing the reviewers.
 *   FALSE is returned on error.
 */
function mcneese_event_workflow_get_reviewers($conditions = array(), $join = FALSE, $sort = array()) {
  if (!is_array($conditions)) {
    cf_error::invalid_array('conditions');
    return FALSE;
  }

  if (!is_bool($join)) {
    cf_error::invalid_bool('join');
    return FALSE;
  }

  if (!is_array($sort)) {
    cf_error::invalid_sort('sort');
    return FALSE;
  }

  try {
    $query = db_select('mew_reviewers', 'mr');
    $query->fields('mr');

    if ($join) {
      $query->innerjoin('users', 'u', 'u.uid = mr.user_id');
      $query->innerjoin('field_data_field_user_first_name', 'fdfufn', 'u.uid = fdfufn.entity_id AND fdfufn.delta = 0');
      $query->innerjoin('field_data_field_user_last_name', 'fdfuln', 'u.uid = fdfuln.entity_id AND fdfuln.delta = 0');
      $query->innerjoin('field_data_field_user_banner_id', 'fdfubi', 'u.uid = fdfubi.entity_id AND fdfubi.delta = 0');

      $query->innerjoin('taxonomy_term_data', 'ttd1', 'ttd1.vid = 1 AND mr.event_classification = ttd1.tid');
      $query->innerjoin('taxonomy_term_data', 'ttd2', 'ttd2.vid = 19 AND mr.review_step = ttd2.tid');
      $query->innerjoin('taxonomy_term_data', 'ttd3', 'ttd3.vid = 17 AND mr.reviewer_classification = ttd3.tid');

      $query->addField('u', 'name', 'name');
      $query->addField('u', 'created', 'created');
      $query->addField('u', 'status', 'status');
      $query->addField('u', 'mail', 'email');

      $query->addField('fdfufn', 'field_user_first_name_value', 'first_name');
      $query->addField('fdfuln', 'field_user_last_name_value', 'last_name');
      $query->addField('fdfubi', 'field_user_banner_id_value', 'banner_id');

      $query->addField('ttd1', 'name', 'event_classification_name');
      $query->addField('ttd2', 'name', 'review_step_name');
      $query->addField('ttd3', 'name', 'reviewer_classification_name');
    }

    if (!empty($conditions)) {
      foreach ($conditions as $condition_id => $condition) {
        $query->condition($condition_id, $condition);
      }
    }

    if (!empty($sort)) {
      foreach ($sort as $sort_name => $sort_value) {
        $query->orderBy($sort_name, $sort_value);
      }
    }

    $results = $query->execute()->fetchAll();
  }
  catch (Exception $ex) {
    cf_error::on_query_execution($ex);

    return FALSE;
  }

  if (is_array($results)) {
    return $results;
  }

  return FALSE;
}

/**
 * Checks to see if the given room is available at the given times.
 *
 * For the dates and times to work properly, it is expected that:
 * - unix timestamps are used.
 * - date values have their time reset to 0 (aka: 12:00:00am).
 * - time values have their dates set to the same day as the date value.
 *
 * @param string $location
 *   The location string.
 * @param string $building
 *   The building string.
 * @param string $room
 *   The room string.
 * @param array $dates
 *   An array containing the date values.
 * @param array $time_start
 *   An array containing the time start values.
 * @param array $time_stop
 *   An array containing the time stop values.
 * @param int|null $event_id
 *   (optional) When not NULL, this represents the event_id to ignore.
 *   Use this so that when editing an existing event, it does not report
 *   itself as the event using the room.
 *
 * @return array|false
 *   An array containing any events currently using the room at the specified date and time.
 *   FALSE on error.
 */
function mcneese_event_workflow_check_room_availability($location, $building, $room, $date, $time_start, $time_stop, $event_id = NULL) {
  if (!is_string($location) || empty($location)) {
    cf_error::invalid_string('location');
    return FALSE;
  }

  if (!is_string($building) || empty($building)) {
    cf_error::invalid_string('building');
    return FALSE;
  }

  if (!is_string($room) || empty($room)) {
    cf_error::invalid_string('room');
    return FALSE;
  }

  if (!is_array($date) || empty($date)) {
    cf_error::invalid_array('date');
    return FALSE;
  }

  if (!is_array($time_start) || empty($time_start)) {
    cf_error::invalid_array('time_start');
    return FALSE;
  }

  if (!is_array($time_stop) || empty($time_stop)) {
    cf_error::invalid_array('time_stop');
    return FALSE;
  }

  if (!is_null($event_id) && !cf_is_integer($event_id)) {
    cf_error::invalid_integer('event_id');
    return FALSE;
  }

  try {
    $query = db_select('mew_event_requests', 'mer');

    $query->innerjoin('mew_current_top', 'mct', 'mer.id = mct.event_id');
    $query->innerjoin('mew_current_dates', 'mcd', 'mer.id = mcd.event_id AND mct.event_id = mcd.event_id');

    $query->innerjoin('mew_field_top_status', 'mfts', 'mct.event_id = mfts.event_id AND mcd.event_id = mfts.event_id AND mct.status = mfts.revision AND mfts.delta = 0');
    $query->innerjoin('mew_field_top_step', 'mftsp', 'mct.event_id = mftsp.event_id AND mcd.event_id = mftsp.event_id AND mct.step = mftsp.revision AND mftsp.delta = 0');
    $query->innerjoin('mew_field_top_location', 'mftl', 'mct.event_id = mftl.event_id AND mcd.event_id = mftl.event_id AND mct.location = mftl.revision AND mftl.delta = 0');
    $query->innerjoin('mew_field_top_building', 'mftb', 'mct.event_id = mftb.event_id AND mcd.event_id = mftb.event_id AND mct.building = mftb.revision AND mftb.delta = 0');
    $query->innerjoin('mew_field_top_room', 'mftr', 'mct.event_id = mftr.event_id AND mcd.event_id = mftr.event_id AND mct.room = mftr.revision AND mftr.delta = 0');

    $query->innerjoin('mew_field_dates_date', 'mfdd', 'mct.event_id = mfdd.event_id AND mcd.event_id = mfdd.event_id AND mcd.date = mfdd.revision');

    $query->addField('mer', 'id', 'event_id');
    $query->addField('mfdd', 'value', 'date');
    $query->addField('mcd', 'date', 'date_revision');
    $query->addField('mcd', 'time_start', 'time_start_revision');
    $query->addField('mcd', 'time_stop', 'time_stop_revision');

    $query->distinct();

    $statuses = array(
      MEW_EVENT_STATUS_LOCKED,
      MEW_EVENT_STATUS_CLOSED_ACCEPTED,
    );

    $query->condition('mfts.value', $statuses, 'IN');
    $query->condition('mftl.value', $location);
    $query->condition('mftb.value', $building);
    $query->condition('mftr.value', $room);
    $query->condition('mfdd.value', $date, 'IN');

    if (!is_null($event_id)) {
      $query->condition('mer.id', $event_id, '<>');
    }

    $results = $query->execute()->fetchAll();

    // no rooms in use.
    if (empty($results)) {
      return array();
    }

    $event_ids = array();

    // the results contain all locked events that have something in the given room during the given date.
    // however, this does not mention the time, so loop through the times and see if they are all valid.
    foreach ($results as $result) {
      $query = db_select('mew_field_dates_date', 'mfdd');

      $query->innerjoin('mew_field_dates_time_start', 'mfdts', 'mfdd.event_id = mfdts.event_id AND mfdd.delta = mfdts.delta');
      $query->innerjoin('mew_field_dates_time_stop', 'mfdtsp', 'mfdd.event_id = mfdtsp.event_id AND mfdd.delta = mfdtsp.delta');

      $query->addField('mfdd', 'event_id', 'event_id');
      $query->addField('mfdd', 'revision', 'revision');
      $query->addField('mfdd', 'delta', 'delta');
      $query->addField('mfdd', 'value', 'date');
      $query->addField('mfdts', 'value', 'time_start');
      $query->addField('mfdtsp', 'value', 'time_stop');

      $query->condition('mfdd.event_id', $result->event_id);
      $query->condition('mfdts.event_id', $result->event_id);
      $query->condition('mfdtsp.event_id', $result->event_id);

      $query->condition('mfdd.revision', $result->date_revision);
      $query->condition('mfdts.revision', $result->time_start_revision);
      $query->condition('mfdtsp.revision', $result->time_stop_revision);

      if (!is_null($event_id)) {
        $query->condition('mfdd.event_id', $event_id, '<>');
      }

      $or = db_or();

      // all day events match, they have NULL for start and stop time values.
      $and = db_and();
      $and->condition('mfdd.value', $date, 'IN');
      $and->isNull('mfdts.value');
      $and->isNull('mfdtsp.value');

      $or->condition($and);

      foreach ($date as $key => $value) {
        // all day events match, they have NULL for start and stop time values.
        if (is_null($time_start[$key]) && is_null($time_stop[$key])) {
          $event_ids[] = $result->event_id;
        }

        $and = db_and();
        $and->condition('mfdd.value', $value);
        $and->condition('mfdts.value', $time_start[$key], '<=');
        $and->condition('mfdtsp.value', $time_start[$key], '>');
        $or->condition($and);

        $and = db_and();
        $and->condition('mfdd.value', $value);
        $and->condition('mfdts.value', $time_stop[$key], '<');
        $and->condition('mfdtsp.value', $time_stop[$key], '>=');
        $or->condition($and);
      }

      $query->condition($or);

      $matches = $query->execute()->fetchAll();

      foreach ($matches as $match) {
        $event_ids[] = $match->event_id;
      }
    }
  }
  catch (Exception $ex) {
    cf_error::on_query_execution($ex);
    return FALSE;
  }

  return $event_ids;
}

/**
 * Prints a warning message about the room being unavailable.
 *
 * @see mcneese_event_workflow_check_room_availability()
 */
function mcneese_event_workflow_display_room_unavailable_message() {
  $unavailable_message = '';
  $unavailable_message .= '<span class="uppercase">Warning</span>: The specified room is currently unavailable. ';
  $unavailable_message .= 'You may still submit this request and your request attempt will still be logged. ';
  drupal_set_message($unavailable_message, 'warning');
}

/**
 * Builds the event pdf and saves it to the local disk.
 *
 * @param int $event_id
 *   The Event ID.
 * @param int $mode
 *   (optional) The page mode used to determine which parts of a page are
 *   processed.
 * @param bool $local
 *   (optional) If TRUE, then the file is saved to the local disk.
 *   If FALSE, then the file is print to stdout.
 *
 * @return bool
 *   TRUE on success, FALSE otherwise.
 */
function mcneese_event_workflow_generate_pdf($event_id, $mode = 1, $local = FALSE) {
  $event = event_workflow_load_event_by_id($event_id);

  if (empty($event)) {
    watchdog('mew', "Unable to find event with id of @event_id.", array('@event_id' => $event_id), WATCHDOG_ERROR);
    return FALSE;
  }

  $form = array();
  $form_state = array();

  $page = array();
  $page['html'] = array(
    '#type' => 'container',
    '#attributes' => array(
      'id' => 'mcneese-event-workflow-event-view-0-page',
      'class' => array(
        'mcneese-event-workflow-event-pdf-0',
      ),
    ),
  );

  $page['html']['content'] = array(mcneese_event_workflow_event_view_0_page($form, $form_state, $event_id, $mode, TRUE));
  $renderred = drupal_render($page);
  $html = drupal_render_page($renderred);

  return mcneese_event_workflow_event_pdf_0_page_using_wkhtmltopdf($event_id, $html, $local);
}

/**
 * Renders a PDF of a given event request using the wkhtmltopdf library.
 *
 * @param int $event_id
 *   The unique identifier for an event request.
 * @param bool $local
 *   (optional) If TRUE, then the file is saved to the local disk.
 *   If FALSE, then the file is print to stdout.
 *
 * @return bool
 *   TRUE on success, FALSE otherwise.
 */
function mcneese_event_workflow_event_pdf_0_page_using_wkhtmltopdf($event_id, $html, $local = FALSE) {
  $event = event_workflow_load_event_by_id($event_id);

  if (empty($event)) {
    watchdog('mew', "Unable to find event with id of @event_id.", array('@event_id' => $event_id), WATCHDOG_ERROR);
    return FALSE;
  }

  if (!is_string($html)) {
    cf_error::invalid_string('html');
    return FALSE;
  }

  if (!is_bool($local)) {
    cf_error::invalid_bool('local');
    return FALSE;
  }

  $library = libraries_load('phpwkhtmltopdf');
  if ($library === FALSE || empty($library['loaded'])) {
    return FALSE;
  }

  // Reconstruct the HTML output.
  $cf_dom = new cf_dom(TRUE, TRUE, TRUE, $html);

  $meta_tags = $cf_dom->get_body()->getElementsByTagName('meta');
  $style_tags = $cf_dom->get_body()->getElementsByTagName('style');
  $link_tags = $cf_dom->get_body()->getElementsByTagName('link');
  $title_tags = $cf_dom->get_body()->getElementsByTagName('title');
  $main_tag = $cf_dom->get_dom()->getElementById('mcneese-content-main');

  $head_markup = '<meta http-equiv="Content-Type" content="text/html; charset=utf-8">';
  $body_markup = '';
  $css_markup = '';

  // meta tags
  foreach ($meta_tags as $tag) {
    $head_markup .= $cf_dom->get_dom()->saveHTML($tag) . "\n";
  }

  // style tags
  $head_markup = '';
  foreach ($style_tags as $tag) {
    // drupal generates css styles using @import, remove all of these.
    $matched = array();
    $matches = preg_match_all('/@import url\("([^"]*)/i', $tag->nodeValue, $matched);

    $media = NULL;
    if ($tag->hasAttribute('media')) {
      $media = $tag->getAttribute('media');
    }
    if (empty($media)) {
      $media = 'all';
    }

    if ($matches > 0) {
      if ($media == 'all' || $media == 'print,embossed,tv' || $media == 'print') {
        $match = array_pop($matched);

        foreach ($match as $m) {
          // skip past css uneeded css
          if ($media == 'all') {
            $parts = explode('/', $m);
            if (!isset($parts[4])) {
              continue;
            }
            if ($parts[3] == 'system') {
            }

            if (isset($parts[5])) {
              if ($parts[5] == 'mcneese') {
              }
              elseif ($parts[5] == 'mcneese_event_workflow') {
              }
              else {
                continue;
              }
            }
          }

          $fixed_path = preg_replace('/\?.*$/i', '', $m);
          $parts = explode('/', $fixed_path);
          array_shift($parts);
          array_shift($parts);
          $fixed_path = implode('/', $parts);
          $content = drupal_load_stylesheet(DRUPAL_ROOT . '/' . $fixed_path);


          if (!empty($content)) {
            // mPDF does not properly support the > selector.
            $css_markup .= preg_replace('@ > @i', ' ', $content);
          }

          unset($content);
          unset($parts);
          unset($fixed_path);
        }
      }
    }
    else {
      $head_markup .= $cf_dom->get_dom()->saveHTML($tag) . "\n";
    }
  }

  if (!empty($css_markup)) {
    $head_markup .= '<style>' . $css_markup . '</style>';
  }

  // link tags
  foreach ($link_tags as $tag) {
    $head_markup .= $cf_dom->get_dom()->saveHTML($tag) . "\n";
  }

  // title tags
  $page_title = "Event Request: " . $event['information']['title'][0]->value;
  $head_markup .= '<title>Event Request #' . $event_id . ': ' . $event['information']['title'][0]->value . '</title>';

  $body_markup .= $cf_dom->get_dom()->saveHTML($main_tag) . "\n";

  $body_class = 'mcneese mcneese-pdf';
  $cf = &drupal_static('cf_theme_get_variables', array());
  if (isset($cf['markup_css']['body']['class'])) {
    $body_class .= $cf['markup_css']['body']['class'];
  }

  $html = '';
  $html = '<!DOCTYPE html>' . "\n";
  $html .= '<html lang="en" dir="ltr">' . "\n";

  $html .= '<head>' . $head_markup . '</head>';
  $html .= '<body class="' . $body_class . '">';
  $html .= '  <div id="mcneese-page" class="mcneese-page">';
  $html .= '    <div id="mcneese-page-content" class="mcneese-content full" role="main">';
  $html .= '    <header class="page-title html_tag-header">';
  $html .= '      <hgroup class="html_tag-hgroup">';
  $html .= '        <h1 class="page-title html_tag-heading" role="main">' . $page_title . '</h1>';
  $html .= '      </hgroup>';
  $html .= '    </header>';
  $html .= '    ' . $body_markup;
  $html .= '    </div>';
  $html .= '  </div>';
  $html .= '</body>';
  $html .= '</html>' . "\n";


  $wkpdf = new WkHtmlToPdf();

  // setup the default options
  $wkpdf->setOptions(array(
    'ignoreWarnings' => TRUE, // when not ignored, the PDF does not get generated.
  ));

  $wkpdf->addPage($html);

  $filename = mcneese_event_workflow_build_filename($event_id, 0);

  if ($local) {
    // save the file, locally.
    $temporary_name = drupal_tempnam('temporary://', 'file');
    $wkpdf->saveAs($temporary_name);

    file_unmanaged_move($temporary_name, 'private://event_requests/local/' . $filename, FILE_EXISTS_REPLACE);
  }
  else {
    // send to the browser
    #$result = $wkpdf->send($filename, TRUE);

    // send as a download
    $result = $wkpdf->send($filename, FALSE);
  }

  if (!$result) {
    watchdog('mew', "Error occured while generating the PDF of event @id: @error", array('@id' => $event_id, '@error' => $wkpdf->getError()), WATCHDOG_ERROR);
  }

  return TRUE;
}

/**
 * Builds the PDF filename string for an event.
 *
 * @param int $event_id
 *   The Event ID.
 * @param int $mode
 *   (optional) Determines how the filename is generated:
 *   0 - use the local filename method.
 *   1 - use the BDM filename PDF.
 *   2 - use the BDM filename Meta.
 *   3 - use the Email filename marker.
 *
 * @return string|false
 *   The built filename string or FALSE on error.
 */
function mcneese_event_workflow_build_filename($event_id, $mode = 0) {
  $event = event_workflow_load_event_by_id($event_id);

  if (empty($event)) {
    watchdog('mew', "Unable to find event with id of @event_id.", array('@event_id' => $event_id), WATCHDOG_ERROR);
    return FALSE;
  }

  if (!cf_is_integer($mode) || $mode < 0 || $mode > 3) {
    cf_error::invalid_integer('mode');
    return FALSE;
  }

  if ($mode == 0) {
    $fixed_title = preg_replace('/\W/i', '_', $event['information']['title'][0]->value);
    $fixed_title = preg_replace('/_+/i', '_', $fixed_title);

    return sprintf("%'010s", $event_id) . '-event_request-' . $fixed_title . '.pdf';
  }

  if ($mode == 1) {
    return sprintf("%'010s", $event_id) . '.pdf';
  }

  if ($mode == 2) {
    return sprintf("%'010s", $event_id) . '.meta';
  }

  if ($mode == 3) {
    return sprintf("%'010s", $event_id) . '.email';
  }

  return FALSE;
}

/**
 * Load a listing of events.
 *
 * This can be used as a very simple and straightforward search.
 *
 * This will load a total results of $limit +1 to communicate when a given
 * result set has more results than the limit. This should help with
 * implementing next and previous options.
 *
 * @param string|null $search
 *   (optional) When not NULL, this is the string of text to search for.
 * @param bool $sensitive
 *   (optional) TRUE for case sensitive and FALSE otherwise.
 * @param int $start
 *   (optional) The starting range.
 * @param bool $limit
 *   (optional) The total number of search results to load.
 * @param array $sorting
 *   (optional) Table sort options.
 * @param array $filter
 *   (optional) Filter displayed fields.
 * @param bool $ignore_decisions
 *   (optional) When TRUE, will not perform additional checks to see if the
 *   current user has already reviewed the event. When FALSE, then listing
 *   will be generated based on whether or not the reviewer has already
 *   reviewed the event for the current step.
 *
 * @return array|FALSE
 *   An array of all items found or FALSE on error.
 */
function mcneese_event_workflow_event_load_listing($search = NULL, $sensitive = FALSE, $start = 0, $limit = 20, $sorting = array(), $filter = array(), $ignore_decisions = TRUE) {
  if (!is_null($search) && !is_string($search)) {
    cf_error::invalid_string('search');
    return FALSE;
  }

  if (!is_bool($sensitive)) {
    cf_error::invalid_bool('sensitive');
    return FALSE;
  }

  if (!cf_is_integer($start) || $start < 0) {
    cf_error::invalid_integer('start');
    return FALSE;
  }

  if (!cf_is_integer($limit) || $limit < 1) {
    cf_error::invalid_integer('limit');
    return FALSE;
  }

  if (!is_array($sorting)) {
    cf_error::invalid_array('sorting');
    return FALSE;
  }

  if (!is_array($filter)) {
    cf_error::invalid_array('filter');
    return FALSE;
  }

  if (!is_bool($ignore_decisions)) {
    cf_error::invalid_boold('ignore_decisions');
    return FALSE;
  }

  $user = cf_current_user();

  $manager = user_access('mcneese event workflow manage');
  $reviewer = user_access('mcneese event workflow review');
  $requester = user_access('mcneese event workflow request');

  $manager_as_administer = FALSE;
  $manager_as_reviewer = FALSE;
  if ($manager) {
    if ($ignore_decisions) {
      $manager_as_administer = TRUE;
    }
    else {
      $manager_as_reviewer = TRUE;
    }
  }

  $s = 'i';
  $like = 'ILIKE';
  if ($sensitive) {
    $s = '';
    $like = 'LIKE';
  }

  // load sorting information
  $order = NULL;
  if (isset($sorting['order'])) {
    $order = strtolower($sorting['order']);
  }

  $sort = NULL;
  if (isset($sorting['sort'])) {
    $sort = strtoupper($sorting['sort']);

    if ($sort != 'ASC' && $sort != 'DESC') {
      $sort = NULL;
    }
  }

  mcneese_event_workflow_include(4);

  $status_options = event_workflow_get_event_status_list_options();
  $step_options = event_workflow_get_event_steps_list_options();
  $location_options = event_workflow_get_event_location_list_options();
  $building_options = event_workflow_get_event_building_list_options();
  $room_options = event_workflow_get_event_room_list_options();
  $information_type_options = event_workflow_get_information_type_list_options();

  // load search options
  if (!is_null($search)) {
    $fixed_text = preg_replace('/(\s)/i', ' ', $search);
    $fixed_text = preg_replace('/\s\s*/i', ' ', $fixed_text);

    $search_parts = explode(' ', $fixed_text);

    // remove empty search parts.
    $remove = array();
    foreach ($search_parts as $key => $search_part) {
      if (empty($search_part) && !is_numeric($search_part)) {
        $remove[$key] = $key;
      }
    }

    foreach ($remove as $key) {
      unset($search_parts[$key]);
    }
    unset($remove);

    // don't search when there is nothing to search for.
    if (empty($search_parts)) {
      return array();
    }

    // quote all except the '*' operator, but preg_quote will change '*'.
    $preg_parts = array();
    foreach ($search_parts as $search_key => $search_part) {
      $preg_part_pieces = explode('*', $search_part);

      if (count($preg_part_pieces) == 1) {
        $preg_parts[$search_key] = $search_part;
        continue;
      }

      $preg_part_pieces_fixed = array();
      foreach ($preg_part_pieces as $preg_part_pieces_key => $preg_part_piece) {
        $preg_part_pieces_fixed[$preg_part_pieces_key] = preg_quote($preg_part_piece, '/');
      }

      $preg_parts[$search_key] = '\b' . implode('.*', $preg_part_pieces_fixed) . '\b';
    }

    $status = array();
    foreach ($preg_parts as $search_part) {
      foreach ($status_options as $key => $option) {
        if (preg_match('/' . $search_part . '/' . $s, $option)) {
          $status[$key] = $key;
        }
      }
    }

    $steps = array();
    foreach ($preg_parts as $search_part) {
      foreach ($step_options as $key => $option) {
        if (preg_match('/' . $search_part . '/' . $s, $option)) {
          $steps[$key] = $key;
        }
      }
    }

    $location = array();
    foreach ($preg_parts as $search_part) {
      foreach ($location_options as $key => $option) {
        if (preg_match('/' . $search_part . '/' . $s, $option)) {
          $location[$key] = $key;
        }
      }
    }

    $building = array();
    foreach ($preg_parts as $search_part) {
      foreach ($building_options as $key => $option) {
        if (preg_match('/' . $search_part . '/' . $s, $option)) {
          $building[$key] = $key;
        }
      }
    }

    $room = array();
    foreach ($preg_parts as $search_part) {
      foreach ($room_options as $key => $option) {
        if (preg_match('/' . $search_part . '/' . $s, $option)) {
          $room[$key] = $key;
        }
      }
    }

    $information_type = array();
    foreach ($preg_parts as $search_part) {
      foreach ($information_type_options as $key => $option) {
        if (preg_match('/' . $search_part . '/' . $s, $option)) {
          $information_type[$key] = $key;
        }
      }
    }
  }

  $found = array();
  try {
    $query = db_select('mew_event_requests', 'mer');

    $query->innerjoin('mew_current_top', 'mct', 'mer.id = mct.event_id');
    $query->innerjoin('mew_current_information', 'mci', 'mer.id = mci.event_id');
    $query->innerjoin('mew_current_dates', 'mcd', 'mer.id = mcd.event_id');

    $query->innerjoin('mew_field_top_status', 'mfts', 'mct.event_id = mfts.event_id AND mct.status = mfts.revision AND mfts.delta = 0');
    $query->innerjoin('mew_field_top_step', 'mftsp', 'mct.event_id = mftsp.event_id AND mct.step = mftsp.revision AND mftsp.delta = 0');
    $query->innerjoin('mew_field_top_location', 'mftl', 'mct.event_id = mftl.event_id AND mct.location = mftl.revision AND mftl.delta = 0');
    $query->innerjoin('mew_field_top_building', 'mftb', 'mct.event_id = mftb.event_id AND mct.building = mftb.revision AND mftb.delta = 0');
    $query->innerjoin('mew_field_top_room', 'mftr', 'mct.event_id = mftr.event_id AND mct.room = mftr.revision AND mftr.delta = 0');

    $query->innerjoin('mew_field_information_title', 'mfit', 'mci.event_id = mfit.event_id AND mci.title = mfit.revision AND mfit.delta = 0');
    $query->innerjoin('mew_field_information_type', 'mfitp', 'mci.event_id = mfitp.event_id AND mci.type = mfitp.revision AND mfitp.delta = 0');

    $query->innerjoin('mew_field_dates_date', 'mfdd', 'mct.event_id = mfdd.event_id AND mcd.date = mfdd.revision AND mfdd.delta = 0');
    $query->innerjoin('mew_field_dates_time_start', 'mfdts', 'mct.event_id = mfdts.event_id AND mcd.time_start = mfdts.revision AND mfdts.delta = 0');
    $query->innerjoin('mew_field_dates_time_stop', 'mfdtsp', 'mct.event_id = mfdtsp.event_id AND mcd.time_stop = mfdtsp.revision AND mfdtsp.delta = 0');

    $query->addField('mfit', 'value', 'title');
    $query->addField('mfit', 'value', 'type');

    $query->addField('mftl', 'value', 'location');
    $query->addField('mftb', 'value', 'building');
    $query->addField('mftr', 'value', 'room');

    $query->addField('mfts', 'value', 'status');
    $query->addField('mftsp', 'value', 'step');

    $query->addField('mfdd', 'value', 'date');
    $query->addField('mfdts', 'value', 'time_start');
    $query->addField('mfdtsp', 'value', 'time_stop');

    $query->fields('mer');

    $query->range($start, $limit + 1);

    if ($manager_as_administer) {
      if (!$ignore_decisions) {
        $show_status = array(
          MEW_EVENT_STATUS_LOCKED,
          MEW_EVENT_STATUS_UNLOCKED,
        );

        $show_step = array(
          MEW_REVIEW_STEP_VENUE_AVAILABLE,
          MEW_REVIEW_STEP_REVIEW,
          MEW_REVIEW_STEP_USAGE_FEES,
          MEW_REVIEW_STEP_MAKE_DECISIONS
        );

        $query->condition('mfts.value', $show_status, 'IN');
        $query->condition('mftsp.value', $show_step, 'IN');
      }
    }
    elseif ($reviewer || $manager_as_reviewer) {
      $query->innerjoin('mew_current_event_coordinator', 'mcec', 'mer.id = mcec.event_id');
      $query->innerjoin('mew_field_event_coordinator_classification', 'mfecc', 'mcec.event_id = mfecc.event_id AND mcec.classification = mfecc.revision AND mfecc.delta = 0');

      $query->innerjoin('mew_current_venue_coordinator', 'mcvc', 'mer.id = mcvc.event_id');
      $query->innerjoin('mew_field_venue_coordinator_user_id', 'mfvcui', 'mcvc.event_id = mfvcui.event_id AND mcvc.user_id = mfvcui.revision AND mfvcui.delta = 0');

      $or = db_or();

      if (!$ignore_decisions) {
        $show_status = array(
          MEW_EVENT_STATUS_LOCKED,
          MEW_EVENT_STATUS_UNLOCKED,
        );

        $show_step = array(
          MEW_REVIEW_STEP_VENUE_AVAILABLE,
          MEW_REVIEW_STEP_MAKE_DECISIONS
        );

        $show_decision = array(
          MEW_REVIEW_DECISION_APPROVE,
          MEW_REVIEW_DECISION_DENY
        );

        $review_query = db_select('mew_field_review_review', 'mfrr');
        $review_query->innerjoin('mew_current_review', 'mcr', 'mfrr.event_id = mcr.event_id and mfrr.revision = mcr.review');

        $review_query->addfield('mfrr', 'step', 'step');

        $review_query->where('mfrr.event_id = mftsp.event_id');
        $review_query->condition('mfrr.user_id', $user->uid);
        $review_query->condition('mfrr.step', $show_step, 'IN');
        $review_query->condition('mfrr.decision', $show_decision, 'IN');
        $review_query->distinct();

        $and = db_and();
        $and->condition('mftsp.value', $show_step, 'IN');
        $and->condition('mftsp.value', $review_query, 'NOT IN');
        $and->condition('mfvcui.value', $user->uid);
        $or->condition($and);
      }
      else {
        $or->condition('mfvcui.value', $user->uid);
      }

      if (!$ignore_decisions) {
        $show_status = array(
          MEW_EVENT_STATUS_LOCKED,
        );

        $show_step = array(
          MEW_REVIEW_STEP_REVIEW,
          MEW_REVIEW_STEP_USAGE_FEES,
        );

        $show_decision = array(
          MEW_REVIEW_DECISION_APPROVE,
          MEW_REVIEW_DECISION_DENY
        );

        # Get all of the existing reviews
        $review_query = db_select('mew_field_review_review', 'r_mfrr');
        $review_query->innerjoin('mew_review_classifications', 'r_mrc', 'r_mfrr.id = r_mrc.review_id');
        $review_query->innerjoin('mew_current_review', 'r_mcr', 'r_mfrr.event_id = r_mcr.event_id and r_mfrr.revision = r_mcr.review');

        $review_query->addfield('r_mrc', 'classification', 'classification');

        $review_query->where('r_mfrr.event_id = mer.id AND r_mfrr.step = mftsp.value');
        $review_query->condition('r_mfrr.step', $show_step, 'IN');
        $review_query->condition('r_mfrr.decision', $show_decision, 'IN');
        $review_query->distinct();

        # Get all of a reviewers classifications for a given event.
        $classifications_query = db_select('mew_reviewers', 'c_mr');

        $classifications_query->addfield('c_mr', 'reviewer_classification', 'reviewer_classification');

        $classifications_query->where('c_mr.event_classification = mfecc.value AND c_mr.review_step = mftsp.value');
        $classifications_query->condition('c_mr.user_id', $user->uid);
        $classifications_query->condition('c_mr.reviewer_classification', $review_query, 'NOT IN');
        $classifications_query->range(0, 1);

        # Check to see if the user can review.
        # The user does not have to be the user who reviewed for a given reviewer_classification, but he must be a valid user for the event_classification and review step.
        $can_review_query = db_select('mew_reviewers', 'c_mr_2');

        $can_review_query->addfield('c_mr_2', 'user_id', 'user_id');

        $can_review_query->where('c_mr_2.event_classification = mfecc.value AND c_mr_2.review_step = mftsp.value');
        $can_review_query->condition('c_mr_2.user_id', $user->uid);
        $can_review_query->distinct();

        $and = db_and();
        $and->condition(1, $classifications_query, 'NOT IN');
        $and->condition($user->uid, $can_review_query, 'IN');
        $and->condition('mfts.value', $show_status, 'IN');

        $or->condition($and);
      }
      else {
        $reviewers_query = db_select('mew_reviewers', 'mr');
        $reviewers_query->condition('mr.user_id', $user->uid);
        $reviewers_query->addfield('mr', 'event_classification', 'event_classification');
        $reviewers_query->addfield('mr', 'review_step', 'review_step');
        $reviewers_query->distinct();

        $reviewers_results = $reviewers_query->execute()->fetchAll();
        if (!empty($reviewers_results)) {
          foreach ($reviewers_results as $reviewers_result) {
            $and = db_and();
            $and->condition('mfecc.value', $reviewers_result->event_classification);
            $and->condition('mftsp.value', $reviewers_result->review_step);
            $or->condition($and);
          }
        }
      }

      $query->condition($or);
    }
    elseif ($requester) {
      // load all events created by the requester who is neither an admin nor a manager.
      if (!$manager) {
        $query->condition('mer.user_id', $user->uid);
      }
    }
    else {
      // failsafe, should never happen.
      drupal_access_denied();
      drupal_exit();
      return FALSE;
    }

    // do not include deleted requests.
    $query->condition('mfts.value', MEW_EVENT_STATUS_DELETED, '<>');

    if (!is_null($search)) {
      $or = db_or();

      foreach ($search_parts as $search_part) {
        $search_part_pieces = explode('*', $search_part);

        if (count($search_part_pieces) == 1) {
          $or->condition('mfit.value', db_like($search_part), $like);
          $or->condition('mfit.value', '%' . db_like($search_part) . '%', $like);
          continue;
        }

        $search_part_pieces_fixed = array();
        foreach ($preg_part_pieces as $preg_part_pieces_key => $preg_part_piece) {
          $search_part_pieces_fixed[$preg_part_pieces_key] = db_like($preg_part_piece);
        }

        $search_part_pieces_combined = implode('%', $search_part_pieces_fixed);
        $or->condition('mfit.value', $search_part_pieces_combined, $like);
        $or->condition('mfit.value', '%' . $search_part_pieces_combined . '%', $like);
      }

      if (!empty($status)) {
        $or->condition('mfts.value', $status, 'IN');
      }

      if (!empty($steps)) {
        $or->condition('mftsp.value', $steps, 'IN');
      }

      if (!empty($location)) {
        $or->condition('mftl.value', $location, 'IN');
      }

      if (!empty($building)) {
        $or->condition('mftb.value', $building, 'IN');
      }

      if (!empty($room)) {
        $or->condition('mftr.value', $room, 'IN');
      }

      if (!empty($information_type)) {
        $or->condition('mfitp.value', $information_type, 'IN');
      }

      $query->condition($or);
    }

    if (is_null($order)) {
      $query->orderBy('created', 'DESC');
    }
    else {
      if ($order == 'id') {
        $query->orderBy('mer.id', is_null($sort) ? 'DESC' : $sort);
      }
      elseif ($order == 'title') {
        $query->orderBy('title', is_null($sort) ? 'ASC' : $sort);
      }
      elseif ($order == 'status') {
        $query->orderBy('status', is_null($sort) ? 'ASC' : $sort);
      }
      elseif ($order == 'step') {
        $query->orderBy('step', is_null($sort) ? 'ASC' : $sort);
      }
      elseif ($order == 'location') {
        $query->orderBy('location', is_null($sort) ? 'ASC' : $sort);
      }
      elseif ($order == 'building') {
        $query->orderBy('building', is_null($sort) ? 'ASC' : $sort);
      }
      elseif ($order == 'room') {
        $query->orderBy('room', is_null($sort) ? 'ASC' : $sort);
      }
      elseif ($order == 'date') {
        // @todo: find a way to sort by dates (due to multiple values, one cannot simply just sort delta = 0).
        $query->orderBy('date', is_null($sort) ? 'ASC' : $sort);
        $query->orderBy('time_start', is_null($sort) ? 'ASC' : $sort);
      }
      elseif ($order == 'submitted by') {
        $query->orderBy('user_id', is_null($sort) ? 'ASC' : $sort);
      }
      elseif ($order == 'submitted on') {
        $query->orderBy('created', is_null($sort) ? 'DESC' : $sort);
      }
    }

    $results = $query->execute()->fetchAll();

    foreach ($results as $result) {
      if (array_key_exists($result->id, $found)) {
        continue;
      }
      else {
        $found[$result->id] = $result;

        if ($found[$result->id] === FALSE) {
          unset($found[$result->id]);
          continue;
        }
      }

      // fetch all available dates:
      $sub_query = db_select('mew_current_dates', 'mcd');
      $sub_query->innerjoin('mew_field_dates_date', 'mfdd', 'mcd.event_id = mfdd.event_id AND mcd.date = mfdd.revision');
      $sub_query->innerjoin('mew_field_dates_time_start', 'mfdts', 'mcd.event_id = mfdts.event_id AND mcd.time_start = mfdts.revision and mfdd.event_id = mfdts.event_id and mfdd.delta = mfdts.delta');
      $sub_query->innerjoin('mew_field_dates_time_stop', 'mfdtsp', 'mcd.event_id = mfdtsp.event_id AND mcd.time_start = mfdtsp.revision and mfdd.event_id = mfdts.event_id and mfdd.delta = mfdtsp.delta');

      $sub_query->addField('mfdd', 'value', 'date');
      $sub_query->addField('mfdd', 'delta', 'delta');
      $sub_query->addField('mfdts', 'value', 'time_start');
      $sub_query->addField('mfdtsp', 'value', 'time_stop');

      $sub_query->condition('mfdd.event_id', $result->id);

      $sub_query->orderBy('date', 'ASC');
      $sub_query->orderBy('time_start', 'ASC');

      $sub_executed = $sub_query->execute();
      $sub_results = $sub_executed->fetchAll();

      $found[$result->id]->date = array();
      $found[$result->id]->time_start = array();
      $found[$result->id]->time_stop = array();

      foreach ($sub_results as $delta => $sub_result) {
        $found[$result->id]->date[$sub_result->delta] = $sub_result->date;
        $found[$result->id]->time_start[$sub_result->delta] = $sub_result->time_start;
        $found[$result->id]->time_stop[$sub_result->delta] = $sub_result->time_stop;
      }
    }
  }
  catch (Exception $ex) {
    if (class_exists('cf_error')) {
      cf_error::on_query_execution($ex);
    }

    return FALSE;
  }

  if (!is_null($order)) {
    $ordered = array();

    if ($order == 'status') {
      foreach ($found as $event_id => $field) {
        $ordered[$status_options[$field->status]][$field->id] = $field;
      }
    }
    elseif ($order == 'step') {
      foreach ($found as $event_id => $field) {
        $ordered[$step_options[$field->step]][$field->id] = $field;
      }
    }
    elseif ($order == 'location') {
      foreach ($found as $event_id => $field) {
        $ordered[$location_options[$field->location]][$field->id] = $field;
      }
    }
    elseif ($order == 'building') {
      $ordered = array();

      foreach ($found as $event_id => $field) {
        $ordered[$building_options[$field->building]][$field->id] = $field;
      }
    }
    elseif ($order == 'room') {
      $ordered = array();

      foreach ($found as $event_id => $field) {
        $ordered[$room_options[$field->room]][$field->id] = $field;
      }
    }

    if (!empty($ordered)) {
      if ($sort == 'DESC') {
        krsort($ordered);
      }
      else {
        ksort($ordered);
      }

      $found = array();
      foreach ($ordered as $key => $fields) {
        $found = array_merge($found, $fields);
      }
    }
  }

  return $found;
}

/**
 * Changes a form field's required state.
 *
 * @param string $field
 *   The array path name of the field.
 * @param array $form
 *   The form array where the field is stored.
 *   This will be updated.
 * @param bool $is_required
 *   Whether or not to change the field to required or not required.
 *
 * @return bool
 *   TRUE on successfull processing, FALSE otherwise.
 */
function mcneese_event_workflow_assign_validation_requirement($field, &$form, $is_required) {
  if (!is_string($field)) {
    cf_error::invalid_string('field');
    return FALSE;
  }

  if (!is_array($form)) {
    cf_error::invalid_array('form');
    return FALSE;
  }

  if (!is_bool($is_required)) {
    cf_error::invalid_bool('is_required');
    return FALSE;
  }

  $parts = explode('][', $field);

  $found = TRUE;
  $location = &$form;
  while (!empty($parts)) {
    $part = array_shift($parts);
    if (!is_array($location) || !array_key_exists($part, $location)) {
      $found = FALSE;
      break;
    }

    $location = &$location[$part];
  }

  if ($found && !empty($location)) {
    foreach ($location as $delta => &$location_field) {
      if (!is_numeric($delta)) continue;

      if (array_key_exists('#required', $location_field)) {
        if (isset($location['#options']) && is_array($location_field['#options'])) {
          if ($is_required) {
            if (array_key_exists('', $location_field['#options'])) {
              unset($location_field['#options']['']);
            }
          }
          else {
            if (!array_key_exists('', $location_field['#options'])) {
              $location_field['#options'][''] = '';
            }
          }
        }

        $location_field['#required'] = $is_required;
      }
    }
  }

  return TRUE;
}

/**
 * Loads the reviews by step, classification, and date.
 *
 * @parem int $event_id
 *   The numeric event id representing the event request to process.
 * @parem array $steps
 *   (optional) Limit the results to only the provided steps.
 * @parem array $decisions
 *   (optional) An array of decisions to limit the results to.
 *
 * @return array|bool
 *   An array of reviews by order of step, classification, and then date
 *   (with the date descending). FALSE is returned on error.
 */
function mcneese_event_workflow_get_latest_reviews($event_id, $steps = array(), $decisions = array()) {
  if (!cf_is_integer($event_id)) {
    cf_error::invalid_integer('event_id');
    return FALSE;
  }

  if (!is_array($steps)) {
    cf_error::invalid_array('steps');
    return FALSE;
  }

  if (!is_array($decisions)) {
    cf_error::invalid_array('decisions');
    return FALSE;
  }

  $reviews = array();
  try {
    $query = db_select('mew_field_review_review', 'mfrr');

    $query->innerjoin('mew_review_classifications', 'mrc', 'mfrr.id = mrc.review_id');
    $query->innerjoin('mew_current_review', 'mcr', 'mfrr.event_id = mcr.event_id and mfrr.revision = mcr.review');

    $query->addField('mfrr', 'id', 'id');
    $query->addField('mfrr', 'user_id', 'user_id');
    $query->addField('mfrr', 'date', 'date');
    $query->addField('mfrr', 'step', 'step');
    $query->addField('mfrr', 'decision', 'decision');
    $query->addfield('mrc', 'classification', 'classification');

    $query->condition('mfrr.event_id', $event_id);

    if (!empty($steps)) {
      $query->condition('mfrr.step', $steps, 'IN');
    }

    if (!empty($decisions)) {
      $query->condition('mfrr.decision', $decisions, 'IN');
    }

    $query->orderBy('mfrr.step');
    $query->orderBy('mrc.classification');
    $query->orderBy('mfrr.date', 'DESC');

    $results = $query->execute()->fetchAll();
    if (is_array($results)) {
      foreach ($results as $result) {

        if (!isset($reviews[$result->step])) {
          $reviews[$result->step] = array();
        }

        if (!isset($reviews[$result->step][$result->classification])) {
          $reviews[$result->step][$result->classification] = array();
        }

        $reviews[$result->step][$result->classification][$result->id] = $result;
      }
    }
  }
  catch (Exception $ex) {
    cf_error::on_exception($ex);

    return FALSE;
  }

  return $reviews;
}

/**
 * @} End of '@defgroup mcneese_event_workflow McNeese Event Workflow'.
 */
